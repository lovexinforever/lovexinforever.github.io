<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[react native 仿照喜马拉雅音频详情页的滑动卡片特效]]></title>
    <url>%2F2020%2F08%2F07%2Freact-native-%E4%BB%BF%E7%85%A7%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85%E9%9F%B3%E9%A2%91%E8%AF%A6%E6%83%85%E9%A1%B5%E7%9A%84%E6%BB%91%E5%8A%A8%E5%8D%A1%E7%89%87%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[最近听喜马拉雅, 发现喜马拉雅的详情滑动卡片效果很赞, 就很想做一个, 然后就用 react native 做了一个类似的. 效果废话不多说, 先看最终实现的效果 思路页面组成 底部详情介绍页面 浮动在底部的菜单栏 跟随底部详情页的菜单栏 (此菜单栏和浮动的菜单栏一样) 详情页组成 app header app detail container app bottom app float menu container app detail bottom menu app bottom (占位) app float menu container(占位高度) 详情页页面种类 detail container Height &lt; screenHeight - app Header Height detail container Height &gt; screenHeight - app Header Height 当中间详情页内容高度小于 屏幕高度- 头部高度时, 需要一个占位的 view 来撑满屏幕12345&#123;/*当前 stickHeight &lt; scrollMin 高度时, 占位 view , 保证可滑动距离&gt;= scrollMin*/&#125; &#123; stickHeight &lt; scrollContainerMinHeight &amp;&amp; &lt;View style=&#123;&#123;height: scrollContainerMinHeight - stickHeight&#125;&#125;/&gt; &#125; 当滑动距离小于 screenHeight - app header height - app bottom height - app float container Height 时, 显示 float menu12345&#123;/*当滑动距离scollY &lt; realContainerHeight 时, 占位, 已便让内容能滑动上来*/&#125; &#123; isShowFloatMenu &amp;&amp; &lt;View style=&#123;&#123;height: bottomHeight + globalConfig.bookCardPadding&#125;&#125;/&gt; &#125; 详情页实际 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;View onLayout=&#123;e =&gt; &#123; this._getHeaderHeight(e.nativeEvent.layout)&#125;&#125;&gt; &lt;App Header&gt;........&lt;/App Header&gt;&lt;/View&gt;&#123;/*=======================header end======================*/&#125;&lt;Animated.ScrollView onLayout=&#123;e =&gt; &#123; this._getHeight(e.nativeEvent.layout); &#125;&#125; ref=&#123;scroll =&gt; (this.scroll = scroll)&#125; onScroll=&#123;Animated.event( [ &#123; nativeEvent: &#123;contentOffset: &#123;y: this.state.scrollY&#125;&#125; &#125; ], &#123;useNativeDriver: true&#125; )&#125; onMomentumScrollEnd=&#123; e =&gt; this._contentViewScroll(e, false) &#125; scrollEnabled=&#123;contentScrollViewCanBeScroll&#125; scrollEventThrottle=&#123;0.5&#125; // scrollEnabled=&#123;false&#125;&gt; &lt;View style=&#123;[globalStyles.container]&#125;&gt; &#123;/* ====================== scroll container ===================*/&#125; &lt;DetailItem detail=&#123;params&#125;/&gt; &#123;/* ==========detail container end ========== */&#125; &#123;/* ====================== scroll end ===================*/&#125; &#123;/*当前 stickHeight &lt; scrollMin 高度时, 占位 view , 保证可滑动距离&gt;= scrollMin*/&#125; &#123; stickHeight &lt; scrollContainerMinHeight &amp;&amp; &lt;View style=&#123;&#123;height: scrollContainerMinHeight - stickHeight&#125;&#125;/&gt; &#125; &#123;/*当滑动距离scollY &lt; realContainerHeight 时, 占位, 已便让内容能滑动上来*/&#125; &#123; isShowFloatMenu &amp;&amp; &lt;View style=&#123;&#123;height: bottomHeight + globalConfig.bookCardPadding&#125;&#125;/&gt; &#125; &lt;View&gt; &#123; this._renderMenu() &#125; &lt;/View&gt; &lt;/View&gt;&lt;/Animated.ScrollView&gt;&#123; this._renderFloatMenu()&#125;&lt;View onLayout=&#123;e =&gt; &#123; this._getBottomHeight(e.nativeEvent.layout) &#125;&#125; style=&#123;[globalStyles.horizontal_end_container, globalStyles.center, globalStyles.center3, globalStyles.container, &#123; position: 'absolute', bottom: 0, backgroundColor: colors.white, borderTopRightRadius: 10, borderTopLeftRadius: 10, padding: 10, &#125;]&#125;&gt; &lt;App bottom&gt;.......&lt;/app bottom&gt;&lt;/View&gt; 手势监听通过监听手势来改变 float menu 的 translateY 值来实现根据手势滑动移动 float menu 手势滑动 view1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import React, &#123;PureComponent&#125; from "react";import &#123; View, PanResponder&#125; from "react-native";import * as logger from "../../utils/logger";import PropTypes from "prop-types";import globalConfig from "../../config/globalConfig";class PanMoveView extends PureComponent &#123; componentWillMount() &#123; this._panResponder = PanResponder.create(&#123; onStartShouldSetPanResponder: (evt, gestureState) =&gt; &#123; return this.props.isAble; &#125;, onMoveShouldSetPanResponder: (evt, gestureState) =&gt; &#123; if (gestureState) &#123; const &#123;dy, dx&#125; = gestureState; return (Math.abs(dy) &gt;= globalConfig.panMoveConfig.moveMin || Math.abs(dx) &gt;= globalConfig.panMoveConfig.moveMin) &amp;&amp; this.props.isAble &#125; return this.props.isAble; &#125;, onPanResponderGrant: (evt, gestureState) =&gt; &#123; // this._highlight(); if (this.props.handleGrant) &#123; this.props.handleGrant() &#125; &#125;, onPanResponderMove: (evt, gestureState) =&gt; &#123; logger.log('gsMove====&gt;&gt;&gt;&gt;&gt;', gestureState) if (this.props.handleMove) &#123; this.props.handleMove(gestureState) &#125; &#125;, onPanResponderRelease: (evt, gestureState) =&gt; &#123; logger.log('gsRelease', gestureState) if (this.props.handleRelease) &#123; this.props.handleRelease(gestureState) &#125; &#125;, onPanResponderTerminate: (evt, gestureState) =&gt; &#123; &#125;, &#125;); &#125; render() &#123; const &#123; children, style &#125; = this.props; return ( &lt;View style=&#123;style&#125; &#123;...this._panResponder.panHandlers&#125; &gt; &#123;children&#125; &lt;/View&gt; ); &#125;&#125;PanMoveView.propTypes = &#123; handleMove: PropTypes.func.isRequired, handleRelease: PropTypes.func.isRequired, handleGrant: PropTypes.func, isAble: PropTypes.bool.isRequired&#125;export default PanMoveView float menu12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 固定底部的 menu * @private */ _renderFloatMenu = () =&gt; &#123; const &#123; scrollTabViewHeight, scrollY, nowScrollY, bottomHeight, realContainerHeight, panMoveIsTop , cardParentContainerHeight, isShowFloatMenu, panMoveMarginTop, panMoveViewIsAble, tabTransformY , scrollContainerMinHeight &#125; = this.state; return isShowFloatMenu &amp;&amp; &lt;PanMoveView style=&#123;&#123; position: 'absolute', height: cardParentContainerHeight + panMoveMarginTop, bottom: bottomHeight, &#125;&#125; handleMove=&#123;this._handleMove&#125; handleRelease=&#123;this._handleRelease&#125; handleGrant=&#123;this._handleGrant&#125; isAble=&#123;panMoveViewIsAble&#125;&gt; &lt;Animated.View style=&#123;&#123; transform: [ &#123;translateY: tabTransformY&#125; ], height: (scrollTabViewHeight &lt; scrollContainerMinHeight ? scrollContainerMinHeight : scrollTabViewHeight) + bottomHeight &#125; &#125;&gt; &lt;ScrollTabView initialPage=&#123;0&#125; onChangeTab=&#123;obj =&gt; &#123; this._handleChangeTab(obj); &#125;&#125; style=&#123;[ &#123; height: scrollTabViewHeight, backgroundColor: colors.white, borderTopRightRadius: 20, borderTopLeftRadius: 20, &#125; ]&#125; borderBottomWidth=&#123;0&#125; renderTabBar=&#123;() =&gt; &lt;RenderTab stickyHeaderY=&#123;realContainerHeight&#125; stickyScrollY=&#123;scrollY&#125; needPadding=&#123;false&#125; nowScrollY=&#123;nowScrollY&#125; normalActiveColor=&#123;colors.theme_header_bg&#125; normalBgColor=&#123;colors.white&#125; normalUnActiveColor=&#123;colors.black36&#125; borderTopLeftRadius=&#123;20&#125; borderTopRightRadius=&#123;20&#125; topBgColor=&#123;colors.white&#125; isShowMove=&#123;true&#125; isAbleMove=&#123;panMoveIsTop&#125; handleGrant=&#123;this._handleGrant&#125; handleMove=&#123;this._handleMove&#125; handleRelease=&#123;this._handleRelease&#125; topActiveColor=&#123;colors.theme_header_bg&#125; topUnActiveColor=&#123;colors.black36&#125;/&gt;&#125;&gt; &#123;this._renderBookList()&#125; &#123;this._renderBookNote()&#125; &#123;this._renderBookRelate()&#125; &lt;/ScrollTabView&gt; &lt;/Animated.View&gt; &lt;/PanMoveView&gt; &#125; handle move12345678910111213141516171819_handleMove = (gs) =&gt; &#123; const &#123;dy&#125; = gs; let &#123;moveTempY, containerHeight, nowScrollY&#125; = this.state; moveTempY += dy; if (moveTempY &lt; 0) &#123; moveTempY = 0; &#125; else if (moveTempY &gt; containerHeight) &#123; moveTempY = containerHeight &#125; const tabTransformY = moveTempY this.setState(&#123; tabTransformY &#125;) // this.forceUpdate()&#125; handle Release1234567891011121314151617181920212223242526272829303132333435363738394041424344454647_handleRelease = (gs) =&gt; &#123; const &#123;dy&#125; = gs; let &#123; moveTempY, containerHeight, panMoveIsBottom, contentScrollViewCanBeScroll, bottomHeight , realContainerHeight, panMoveMarginTop, nowScrollY, panMoveViewIsAble, scrollContainerMinHeight &#125; = this.state; moveTempY += dy; let panMoveIsTop if (moveTempY &lt; 0) &#123; moveTempY = 0 panMoveIsBottom = false; panMoveIsTop = true; panMoveViewIsAble = false contentScrollViewCanBeScroll = false &#125; else if (moveTempY &lt; utils.getScreenHeight() / 3) &#123; moveTempY = 0 panMoveIsBottom = false; panMoveIsTop = true; panMoveViewIsAble = false contentScrollViewCanBeScroll = false &#125; else if (moveTempY &lt; ((containerHeight - utils.getScreenHeight() / 3) / 2 + utils.getScreenHeight() / 3)) &#123; moveTempY = utils.getScreenHeight() / 3; panMoveIsBottom = false; panMoveIsTop = false; panMoveViewIsAble = true contentScrollViewCanBeScroll = false &#125; else &#123; moveTempY = 0; panMoveIsBottom = true; panMoveIsTop = false; panMoveViewIsAble = true contentScrollViewCanBeScroll = true panMoveMarginTop = -(scrollContainerMinHeight - bottomHeight - globalConfig.bookCardPadding); &#125; this.setState(&#123; moveTempY, tabTransformY: moveTempY, panMoveViewIsAble, panMoveIsBottom, panMoveIsTop, contentScrollViewCanBeScroll, panMoveMarginTop &#125;) // this.forceUpdate() &#125; 主要是通过 move 传递过来的 dy 值来修改 float menu 的translateY 值 然后释放 release 的时候, 根据当前滑动的位置来更新页面到底是滑到中间 还是头部还是底部,最后根据父级的 scrollview 的滑动距离来判断是否显示 float menu.]]></content>
      <categories>
        <category>Technology</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>react native</tag>
        <tag>喜马拉雅</tag>
        <tag>滑动式卡片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react native BottomTabNavigator 点击打开新页面]]></title>
    <url>%2F2019%2F10%2F10%2Freact-native-BottomTabNavigator-%E7%82%B9%E5%87%BB%E6%89%93%E5%BC%80%E6%96%B0%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[最近用rn 做项目, 需要一个需求, 底部tab 中间的tab 不是切换页面, 是跳转到新页面. 查了下 api文档 1234567891011screen: CompanyJobManager, navigationOptions: &#123; tabBarLabel: " ", tabBarIcon: (&#123;tintColor, focused&#125;) =&gt; ( &lt;Image source=&#123;require('./images/add.png')&#125; resize="contains" style=&#123;&#123;width: 40, height: 40, marginTop: 10&#125;&#125;/&gt; ), tabBarOnPress: (&#123;navigation, defaultHandle&#125;) =&gt; &#123; navigation.push('PostJob', &#123;isUpdate: false&#125;) &#125; &#125;,]]></content>
      <categories>
        <category>Technology</category>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>react native</tag>
        <tag>rn</tag>
        <tag>bottomtabnavigator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上用geektool显示最近最近五天的天气(进阶版 根据 ip 位置来显示对应地理位置的天气)]]></title>
    <url>%2F2018%2F12%2F31%2FMac%E4%B8%8A%E7%94%A8geektool%E6%98%BE%E7%A4%BA%E6%9C%80%E8%BF%91%E6%9C%80%E8%BF%91%E4%BA%94%E5%A4%A9%E7%9A%84%E5%A4%A9%E6%B0%94-%E8%BF%9B%E9%98%B6%E7%89%88-%E6%A0%B9%E6%8D%AE-ip-%E4%BD%8D%E7%BD%AE%E6%9D%A5%E6%98%BE%E7%A4%BA%E5%AF%B9%E5%BA%94%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%A4%A9%E6%B0%94%2F</url>
    <content type="text"><![CDATA[前面两篇文章Geektool 使用 python+beautifulsoup 抓取天气显示和Geektool 使用 python + beautiful 实现抓取天气图标 讲解了怎样用 python + geektool来抓取天气网站信息来显示.这篇文章主要来说明怎样根据 ip 来显示地理位置的最近五天的天气. 效果老规矩 先看最终效果图 设计思路 获取所处的外网 ip 根据外网 ip 获取地理位置名称 设计字典, 根据地理位置来获取天气的 key, 拼接天气 url 来获取当前 ip 的地理位置的天气. 获取外网所在的 ip浏览器打开地址 http://ip.42.pl/raw, 可以看到当前的外网 ip.直接解析.1234567def get_ip(): url='http://ip.42.pl/raw' head=&#123;&#125; head['User-Agent']='Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36' req=urllib2.Request(url,headers=head) ip = urllib2.urlopen(req).read(); return ip 根据 ip 获取所处的地理位置1234567891011def queryIpAddress(ipaddress): url='https://ip.cn/index.php?ip='+ipaddress head=&#123;&#125; head['User-Agent']='Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36' req=urllib2.Request(url,headers=head) reaponse = urllib2.urlopen(req); soup=BeautifulSoup(reaponse,'html.parser'); a = soup.find('div', attrs=&#123;'class': 'well'&#125;) b = a.find_all('p')[1].find('code').get_text(); address = b.split(' ')[0] return address 创建城市字典由于常年呆在南京, 就只写了几个城市码, 如果没有你所在的城市, 自己去创建下12345&#123; "江苏省南京市": "5ef652409badc75c97292b401c6db8e8e55a3157f300dc0997bea96343e4a20a", "广东省珠海市": "ba75fa9fa1fb4e2709d1c5a015354ac188cc2a50902610a80f9d28dce8eb8e40", "广东省广州市": "8531a23947fdad24dcfb9cd37e6d6bd77617fa7c8b242e4773c74381cf55845b"&#125; 根据城市名字获取城市的天气 key因为我在南京,所以如果没有取到 key 的话, 我会默认给南京的 key12345678910def queryCode(key): f = open("/Users/dingyang/python/geektool/city.json") origin = json.load(f); if(key in origin): # 获取城市编码 code = origin[key]; # 如果城市编码为空, 默认给南京编码 else: code = "5ef652409badc75c97292b401c6db8e8e55a3157f300dc0997bea96343e4a20a" return code; 根据返回的key, 组装 url,获取天气展示.1234567891011121314def getDate(): addr = address.queryIpAddress(address.get_ip()) code = city.queryCode(addr) url = "https://weather.com/zh-CN/weather/5day/l/"+code respFive=urllib.urlopen(url); soupFive=BeautifulSoup(respFive,'html.parser'); # 最近五天 fives=soupFive.find_all('tr',attrs=&#123;'class':'clickable'&#125;); week=fives[1].find_all('td',attrs=&#123;'class':'twc-sticky-col'&#125;)[1]; weekDate=week.find('span',attrs=&#123;'class':'day-detail'&#125;); return weekDate.get_text(); geektool 输出信息.用 geektool 输出天气信息,然后自己调整样式.]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>geektool</tag>
        <tag>天气</tag>
        <tag>beautifulsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中强大的控件库 TDLibrary(持续更新)]]></title>
    <url>%2F2018%2F12%2F05%2FAndroid%E4%B8%AD%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%8E%A7%E4%BB%B6%E5%BA%93-TDLibrary-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[Android 项目中最强大的控件库 TDLibrary, 持续更新中, 继承各方的控件和工具类,让你无需在使用控件而烦恼. TDLibraryTDLibrary 是一个 android 上面经常用到的控件库和一些工具类. LicenseTDLibrary is licensed under the Apache 2.0 License Copyright 2018 TIMDING InstallationJCenter 引用Add TDLibrary as a dependency to your build.gradle123dependencies &#123; implementation 'com.tim:tdlibrary:1.0.3'&#125; jitpack 引用Add it in your root build.gradle at the end of repositories:123456allprojects &#123; repositories &#123; ... maven &#123; url 'https://jitpack.io' &#125; &#125; &#125; Add the dependency 123dependencies &#123; implementation 'com.github.lovexinforever:TDLibrary:v1.0.3'&#125; Usage可控输入个数的验证码输入框效果 使用在 xml 中引入控件12345678910111213141516&lt;com.tim.tdlibrary.ActivationCodeView android:id="@+id/icv" android:layout_width="match_parent" android:layout_height="60dp" android:layout_centerHorizontal="true" android:layout_marginLeft="10dp" android:layout_marginRight="10dp" android:layout_marginTop="26dp" app:icv_et_bg_focus="@drawable/shape_icv_et_bg_focus" app:icv_et_bg_normal="@drawable/shape_icv_et_bg_normal" app:icv_et_divider_drawable="@drawable/shape_divider_identifying" app:icv_et_number="5" app:icv_text_bg_alpha="100" app:icv_et_text_color="#fff" app:icv_text_count_num="4" app:icv_et_width="60dp"/&gt; java 中监听输入框内容变化1234567891011mActivationCodeView.setInputCompleteListener(new ActivationCodeView.InputCompleteListener() &#123; @Override public void inputComplete() &#123; updateViewAfterInput(); &#125; @Override public void deleteContent() &#123; updateViewAfterInput(); &#125; &#125;); 横向滚动的跑马灯效果 使用在 xml 中引用控件123456&lt;com.tim.tdlibrary.marquee.MarqueeTextView android:id="@+id/text" app:text_color="#ff77dd" app:text_size="@dimen/sp_15" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; java 中调用 setText 方法123MarqueeTextView marqueeTextView = findViewById(R.id.text); marqueeTextView.setText("测试测试测试发的卡积分考虑到撒酒疯林科大实际付款老司机发的可使肌肤都是框架范德萨开了房觉得上路"); 视图标签效果 使用在 xml 中引用控件123456789101112131415161718192021222324252627282930313233&lt;com.tim.tdlibrary.laberview.LabelButtonView android:id="@+id/labelbutton" android:layout_width="200dp" android:layout_height="48dp" android:background="#03a9f4" android:gravity="center" android:text="Button" android:textColor="#ffffff" app:label_backgroundColor="#C2185B" app:label_distance="20dp" app:label_height="20dp" app:label_orientation="RIGHT_TOP" app:label_text="HD" app:label_textSize="12sp" app:label_textStyle="BOLD"/&gt; &lt;com.tim.tdlibrary.laberview.LabelTextView android:id="@+id/text" android:layout_width="wrap_content" android:layout_height="48dp" android:layout_gravity="center" android:layout_marginTop="8dp" android:background="#212121" android:gravity="center" android:padding="16dp" android:text="TextView" android:textColor="#ffffff" app:label_backgroundColor="#03A9F4" app:label_distance="15dp" app:label_orientation="LEFT_TOP" app:label_text="POP" app:label_textSize="10sp" app:label_textStyle="BOLD_ITALIC"/&gt; 关于我BLOG]]></content>
      <categories>
        <category>Technology</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>Hexo</tag>
        <tag>控件库</tag>
        <tag>tdlibrary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Could not find common.jar (android.arch.core:common:1.1.0)]]></title>
    <url>%2F2018%2F05%2F29%2FCould-not-find-common-jar-android-arch-core-common-1-1-0%2F</url>
    <content type="text"><![CDATA[android studio build 报错 Could not find common.jar (android.arch.core:common:1.1.0) 解决办法. 打开 root build.gradle Add maven { url &#39;https://maven.google.com&#39; } before jcenter() in12345allprojects &#123; repositories &#123; jcenter() &#125;&#125;]]></content>
      <categories>
        <category>Technology</category>
        <category>Journal</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样使用 git 命令来操作 svn 远程仓库]]></title>
    <url>%2F2018%2F05%2F28%2F%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8-git-%E5%91%BD%E4%BB%A4%E6%9D%A5%E6%93%8D%E4%BD%9C-svn-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[之前因为转组,这个组用 svn 管理代码,并没有 git + gerrit来管理代码.由于习惯了使用 git, 所以就使用 git svn 命令来使用 git 命令管理 svn 仓库. 查看 svn 代码结构1234project |___branches |___tags |___trunk 这是我项目的 svn 结构. trunk 是源码, tags 是项目打的 tag, branches 是项目的分支. clone 命令1git svn clone -r 1394873:HEAD http://svn.99bill.net/opt/99billsrc/PMD/Branches/MOB/Android/app-SmartPOS2.0 --username yang.ding@99bill.com --trunk "trunk" --tag "tags" --branch "branches" develop_smartpos 其中 -r 1394873 是 svn 中你需要 clone 的起始 commit. 使用命令git svn fetch 拉去远程代码 git svn rebase 合并远程代码 git svn dcommit 提交代码 git svn tags &#39;des&#39; 打远程 tag git svn branches &#39;branches&#39; 创建远程分支 其他的本地 branches 切换 创建 branches 和 git 命令一样. 主要就是和远程 repo 操作需要用到 git svn 命令. 效果使用 gitk --all 查看 repo. QAQ:如果我在 origin branch a 有个 commit 想提交到 origin branch b, 怎么提交 A:使用 git checkout 切换到 origin branch b, 然后把 commit cherry-pick 过来,再执行 git svn dcommit.]]></content>
      <categories>
        <category>Technology</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Identifiers must have user defined types from the XML file. View is missing]]></title>
    <url>%2F2018%2F05%2F17%2FIdentifiers-must-have-user-defined-types-from-the-XML-file-View-is-missing%2F</url>
    <content type="text"><![CDATA[做项目的时候,用 databinding, 遇到这么个错误123456FAILURE: Build failed with an exception.* What went wrong:Execution failed for task ':mpos-cashier:compileIntegrateJavaWithJavac'.&gt; java.lang.RuntimeException: Found data binding errors. ****/ data binding error ****msg:Identifiers must have user defined types from the XML file. View is missing it file:/Users/dingyang/tim/cfs/git/develop_smartpos/mpos-cashier/src/main/res/layout/activity_home.xml loc:54:65 - 54:68 ****\ data binding error **** 错误原因是 xml 中没有引用 view 这个方法.在 xml 的 layout&gt;data下面引入1&lt;import type="android.view.View"]]></content>
      <categories>
        <category>Technology</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>databinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热修复方案设计文档]]></title>
    <url>%2F2018%2F05%2F08%2F%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[本文主要描述完整可行的热修复技术设计方案,给出客户端与服务器端的相应改造, 并介绍核心实现原理、分析主流框架的优劣势.由于与插件化开发有一定重叠,因此也简单 介绍插件化应用的原理. 整体方案背景当应用发布之后，突然发现严重 bug 需要紧急修复.传统做法是修复后打包为新版 本 App, 再通过应用商店发布新版本,缺点是从修复到用户更新的过程非常缓慢,无法解 决紧急问题.热修复技术通过线上发布补丁, 客户端自动获取补丁后立即加载,即时生效,可以非 常迅速的修复线上问题. 流程本地、服务端、线上版本三方工作时序:1) 通过各种途径获知 bug存在2) 定位并在本地修复3) 制作补丁包4) 发布到服务器端5) 线上版本收到推送6) 下载后加载补丁 时序触发分为客户端主动触发与被动触发: 加载补丁 业务全景全模块 客户端1) 推送模块 PUSH接收推送消息,分发补丁操作的指令.2) 补丁管理模块 PatchManager补丁持久化, 开机自检:管理存储空间,清除临时文件, 维护补丁版本与主程序版本的对应关系, 响应四种推送消息:增、删、改、查: 下 载补丁并加载,删除指定补丁,删除后重下载, 查询当前补丁数量和版本号.3) 安全模块 Secure 校验补丁文件有效性,合法性, 校验文件指纹, 删除非法文件.4) 热修复模块 Core 加载补丁.5) 全局异常模块 UncaughtException 捕获全局异常,触发补丁自动下载.6) 日志模块 Logger 管理日志,主动上送运行异常.7) 容错模块 ErrorHandler校验叠加版本:当前主程序版本+补丁版本 回退机制:删除所有,删除一段时间, 重加载:触发热修复模块重加载. 服务端1) 补丁管理平台 PatchPlatform 提供可视化操作界面: 手动上传、下载补丁文件, 发布补丁,触发推送模块, 统计修复成功率, 登录、用户权限.2) 补丁管理模块 PatchManager 维护补丁版本与主程序版本对应关系, 配 置补丁属性:版本号,对应主程序版本, 增 删改查.3) 推送模块 Push 推送补丁管理的相应指令, 推送日志操作的相应指令.4) 日志模块 Logger 主动或被动获取日志, 跟踪设备使用情况. 热修复技术实现原理实现热修复功能的大方向有两种:NativeHook与替换 Dex.两种流派都各有优缺点, 目前并没有百分之百完美的方案. Native Hook 方式一般情况下,导致 crash 的代码都能最终定位到某一具体的函数, 例如最常见的空指针异常:12345com.tim.patcher E/AndroidRuntime: FATAL EXCEPTION: mainProcess: com.tim.patcher, PID: 20275java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.String java.lang.String.toString()' on a null object referenceat com.tim.patcher.MainActivity$1$override.onClick(MainActivity.java:25)at android.app.ActivityThread.main(ActivityThread.java:5314) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:693) 线下修复的做法是通过上述栈信息找到 MainActivity类,修改第 25行的onClick方法, 而后打包发布.Native 方式的出发点由此而来,如果能动态的将问题函数替换为需要的函数,使程 序在运行到这一步时不执行原函数而去执行新的函数,就能完成热修复了.示意图如下:onClick()是问题函数,onClick_fix()是修复后的函数.执行 dispatch()后绕开 onClick(),转而执行 onClick_fix(),达到修复的目的.关键是用 onClick_fix()替代 onClick()这一步.在 native层, java方法在 Dalvik/ART虚拟机中的实现都会由 C++的 ClassObject 和 Method对象表示,ClassObject记录类的属性,Method记录方法字节码的地址. 只要 在虚拟机执行到要修改的方法前通过其所在的 ClassObject 找到对应的 Method,将 Method的指针指向目标方法就能达到” 绕开” 的目的.具体来说,在这个例子中先将onClick()标记为native方法,然后就可以在jni中获 取它的 ClassObject,通过 ClassObject获取 Method对象,再把 Method指向 java层的 onClick_fix()方法.上述步骤只能替换特定的函数,因为最后一步 Method 指针指向了一个具体的函数. 站在” 造轮子” 的角度上看,实际的使用场景是事先并不能获知目标方法具体是什 么, 因此 Method 指向的目标一定要是可即时改变的.所以在此基础上再进一步,只需要 将指向具体的修复后函数改为指向一个 api 钩子,实现它的回调,就能适用于实际使用场 景, 替换任何待定的函数. Dex 合并方式Dex合并的方式来源于MultiDex还未发布时,为解决方法数限制2^16这一问题而 诞生的 Dex 分包方案.Dex 分包实现了动态加载,动态加载是插件化开发的基础,插件技术 后来引申出了这一类热修复方式.一般来说,插件化是通过动态加载技术实现的,对插件框架稍加改造就可以实现热 修复,因此先简单介绍 Dex分包和插件技术. Dex分包谷歌为了优化安卓应用的运行性能,提出了数据结构和效率比 jar 更好的 dex 格式 .dex 类似于 jar,是一种储存字节码的归档文件.系统启动应用时会先对首次加载的 dex做优化,称为 DexOpt,它会生成一个 Optimised Dex文件.ODex会把应用中所有方 法的 id存储在链表中,但谷歌在这里犯了一个错误,用 short类型保存了这个链表的长度, 导致长度不能超过 short类型最大值 2^16.这就是方法数不能超过 65535的由来.Dex分 包通过将一个应用的 dex拆分成多个来规避这个问题. 插件技术在 Java工程中可以很方便的把 class文件放到jar中直接实现动态加载,但安卓系统 并不支持这样做,因为 jvm执行 class文件而 dvm执行 dex文件.安卓虚拟机不能识别 java的字节码,要将 class转换成 dex文件才能识别,所以拆分的最小单位是 dex.插件技术的关键在于如何动态加载多个 dex.加载插件的过程可以分解为加载代码 (.java)和加载资源(R resource),资源的加载和热修复无关,因此这里只介绍加载类的方 法.Java中用 ClassLoader加载 jar,Android也有自己的 ClassLoader体系,通过这个 体系完成类的加载.如图所示: DexClassLoader和 PathClassLoader是 BaseDexClassLoader的两种实现,他们都能 使被加载的类可以正常识别.两者的区别是 DexClassLoader 可以加载文件系统上的 jar,dex以及 apk,而 PathClassLoader需要提供固定的文件路径(比如/data/app/com.bill99.ian.patcher/base-1.apk ),只能加载已安装到/data/app 下的应用. 在 Application 中系统分配了两种加载方式,安卓系统应用使用 DexClassLoader而非系统应用使用 PathClassLoader加载.插件架构有自己重写 ClassLoader的方案也有直接使用 DexClassLoader让系统 帮助加载的方案.而使用 DexClassLoader的方案与合并 Dex完成热修复的方法非常接 近, 因此下面讨论通过 DexClassLoader加载类的方案.DexClassLoader提供了 loadClass()方法进行类的加载 .loadClass()调用 BaseDexClassLoader中的 findClass(),findClass()根据类名查找到 dex中的 class文件 :123456789@Overrideprotected Class&lt;?&gt; findClass (String name) throws ClassNotFoundException &#123;List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); Class c = pathList.findClass(name, suppressedExceptions);if (c == null) &#123;ClassNotFoundException cnfe = new ClassNotFoundException("Didn't find class \"" + name + "\" on path: " + pathList);for (Throwable t : suppressedExceptions) &#123; cnfe.addSuppressed(t);&#125;throw cnfe; &#125;return c; &#125; 源码中, findClass()实际上调用了 pathList 的 findClass(),pathList 是在 BaseDexClassLoader中创建的 DexPathList对象的实例,DexPathList中 findClass() 代码如下:123456789public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123; for (Element element : dexElements) &#123;DexFile dex = element.dexFile; if (dex != null) &#123;Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);if (clazz != null) &#123; return clazz;&#125; &#125;&#125;if (dexElementsSuppressedExceptions != null) &#123;suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); &#125;return null; &#125; 其实就是遍历 dexElements,调用每个元素的 dexFile对象的 loadClassBinaryName方法.其中 dexElement在 DexPathList中创建:1this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions); makeDexElements最终会调用 dvm对 dex文件进行优化和映射,完成类加载.仅仅加载类文件是不够的,Activity,Service 等组件原来由 AMS 管理生命周期,单纯 的加载 Activity 等类后他们也没有了组件的特殊性,和普通的类没有任何区别.有一种解 决方法是通过在接口中定义各种生命周期方法,由插件的 Activity 实现接口,然后在主程 序中调用接口,人工的制造出生命周期. Dex替换插件动态加载的核心是通过ClassLoader加载多个不同的dex,每个dex中类的完整 路径不允许重复,否则会导致不同 dex之间的类加载错乱.而合并 Dex的热修复方式反其 道而行之,它加载一个命名空间和主程序重复的dex.上图是DexClassLoader加载类的流程,关键是DexPathList中的dexElements数组. ClassLoader 会遍历数组中的 dex,从中找到与要加载的类名对应的 dex,加载完成后返 回 class文件.根据流程图能够得出热修复的关键线索:如果有两个 dex同时能够加载这个 类,也就是两个dex具有重复全路径的类,那么 ClassLoader会调用 dexElements数组中 排在前列的 dex去加载这个类,加载完成后立即返回,顺序排在其后的 dex不会被访问到.对于动态加载框架来说,如果能把dex文件插入这个数组就能加载自己的类.而对于 热修复框架来说,把 dex 插入这个数组并保证其位置在数组最前就能将问题类替换成修复后的类.由于系统没有提供 API 操作 DexPathList 或是 dexElements,需要通过反射从 BaseDexClassLoader 获取 dexPathList,再通过 DexPathList 获取 dexElements,反射 Element 的构造方法创建一个插件的 dexElement,再创建一个新的数组,长度为 dexEments 的长度加上插件 dexElement 的数量,把反射得到的 dexElements 和插件 dexElement对象一并插入数组,最后用新创建的数组替换原来的数组.过程如下图:一般在 Application 的 onCreate()或 attachBaseContext()完成数组替换.至此已 经已经完成了热修复的主体.实际运行过程中还有其他问题,当一个类引用另一个类且他们不在同一个 dex中, 系统会抛出异常 Class resolved by unexpected DEX,原因是 从 dexElements查找到需要的 dex并返回 class后系统会对引用者与被引用者的 dex做 校验,当他们不相同时抛出异常.校验方式是如果 A类和 B类在同一个 dex中，那么 A类 就会被打上 CLASS_ISPREVERIFIED标记,A类被打上标记后不能再引用其他 dex中的类 , 否则报错.如果A类还引用了C类,而 C类在其他dex中,那么 A类将不会被打上标记,这 一点被利用来避免 unexpectedDex错误.大部分做法是在所有类的构造函数中都引用一 个空实现的类,将这个类单独打包为一个dex,在应用启动时先加载这个dex.把引用放在 构造函数中是因为构造函数不会导致方法数增加.在所有类中加入引用的工作量很大也 容易出错,可以用 AOP 的编译工具如 AspectJ 在编译源码时加入引用方法,也可以用 JavaAssist插入字节码. 小结如上所述,热修复技术的两个流派分别是通过 Native Hook 替换问题函数和通过插 入 Dex替换问题类.两个流派都有大规模实际应用,都被证明是稳定的,各有优点也都有不足之处,目前为 止尚未发现十全十美的方法,因此在选型时选择符合当前项目情况和最易使用、能够长 期维护的方案.Native 的原理决定了它只能对函数做修改,不能替换资源如布局文件,图片.优点是任 何修复可以立即生效.Dex 流派能够很好的支持类替换,lib 替换和资源替换,但它的致命缺点是不能即时生 效,加载补丁 dex后必须重启或等待下次开启应用才能生效. 主流框架两个流派分别选取主流的、具有代表性的,并有实践案例的开源框架作对比. DexposedDexposed是最早开源的热修复SDK, 由阿里巴巴团队基于 Xposed框架实现,还能 用作 AOP编程、插桩、SDKHook,被应用在手机淘宝,天猫,MIUI等应用和系统.属于 Native 流派. AndFixAndFix 是支付宝的开源框架,应用于支付宝等 APP.AndFix 属于 Native 流派,在 Dexposed 基础上做了大量完善,支持 Android2.3-Android7.0 全版本,补丁编写没有 门槛,并提供补丁生成工具.缺点是不支持替换资源,不支持替换 lib,不能新增函数;如果补 丁过多会影响程序运行速度. NuwaNuwa属 于 Dex流派,是大众点评的一位工程师根据QQ空间团队分享的实现方式做 的. 优点是支持资源,lib 等替换,缺点在于不能实时生效,必须重启应用或下次开启生效.另 外由于所有类都会被打上预加载标记也会造成启动变慢. Tinker微信团队最近开源了 Tinker,我们直接从它的源码入手开始分析. dev 分支上是最新的 Tinker1.6.1 版本,从类名可以知道 Tinker 处理了类的加载, 资源的加载以及 so 库的加载.我们的关注点在类加载上,根据经验判断,TinkerLoader 类是类加载模块的入口,因此从该类开始:12345678910111213/** * only main process can handle patch version change or incomplete */ @Override public Intent tryLoad(TinkerApplication app) &#123; Intent resultIntent = new Intent(); long begin = SystemClock.elapsedRealtime(); tryLoadPatchFilesInternal(app, resultIntent); long cost = SystemClock.elapsedRealtime() - begin; ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost); return resultIntent; &#125; TinkerLoader.tryLoad()很明显就是加载 dex 的入口函数,这里微信统计了加载时 间,并进入 tryLoadPatchFilesInternal()方法.这个方法较长,主要是对新旧两个 dex 做 合并,这里截取其中关键的步骤:123456789101112131415161718192021222324//now we can load patch jar if (isEnabledForDex) &#123; boolean loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA); if (isSystemOTA) &#123; // update fingerprint after load success patchInfo.fingerPrint = Build.FINGERPRINT; patchInfo.oatDir = loadTinkerJars ? ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH : ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH; // reset to false oatModeChanged = false; if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) &#123; ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL); Log.w(TAG, "tryLoadPatchFiles:onReWritePatchInfoCorrupted"); return; &#125; // update oat dir resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, patchInfo.oatDir); &#125; if (!loadTinkerJars) &#123; Log.w(TAG, "tryLoadPatchFiles:onPatchLoadDexesFail"); return; &#125; &#125; 做 了 很 多 安 全 校 验 的 机 制 以 保 证 dex 可 用 后 , 调 用 TinkerDexLoader.loadTinkerJars()方法.12345678910111213141516@TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH) public static boolean loadTinkerJars(final TinkerApplication application, String directory, String oatDir, Intent intentResult, boolean isSystemOTA) &#123; if (loadDexList.isEmpty() &amp;&amp; classNDexInfo.isEmpty()) &#123; Log.w(TAG, "there is no dex to load"); return true; &#125; PathClassLoader classLoader = (PathClassLoader) TinkerDexLoader.class.getClassLoader(); if (classLoader != null) &#123; Log.i(TAG, "classloader: " + classLoader.toString()); &#125; else &#123; Log.e(TAG, "classloader is null"); ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL); return false; &#125; String dexPath = directory + "/" + DEX_PATH + "/"; loadTinkerJars()获取 PathClassLoader并读取dex与 dvm优化后的 odex地址,1234567891011121314151617181920// verify merge classN.apk if (isVmArt &amp;&amp; !classNDexInfo.isEmpty()) &#123; File classNFile = new File(dexPath + ShareConstants.CLASS_N_APK_NAME); long start = System.currentTimeMillis(); if (application.isTinkerLoadVerifyFlag()) &#123; for (ShareDexDiffPatchInfo info : classNDexInfo) &#123; if (!SharePatchFileUtil.verifyDexFileMd5(classNFile, info.rawName, info.destMd5InArt)) &#123; ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH); intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISMATCH_DEX_PATH, classNFile.getAbsolutePath()); return false; &#125; &#125; &#125; Log.i(TAG, "verify dex file:" + classNFile.getPath() + " md5, use time: " + (System.currentTimeMillis() - start)); legalFiles.add(classNFile); &#125; File optimizeDir = new File(directory + "/" + oatDir); 接着遍历 dexList,过滤 md5 不符校验不通过的,调用 SystemClassLoaderAdder 的 installDexs()方法.123456789101112131415161718192021222324252627282930313233@SuppressLint("NewApi") public static void installDexes(Application application, PathClassLoader loader, File dexOptDir, List&lt;File&gt; files) throws Throwable &#123; Log.i(TAG, "installDexes dexOptDir: " + dexOptDir.getAbsolutePath() + ", dex size:" + files.size()); if (!files.isEmpty()) &#123; files = createSortedAdditionalPathEntries(files); ClassLoader classLoader = loader; if (Build.VERSION.SDK_INT &gt;= 24 &amp;&amp; !checkIsProtectedApp(files)) &#123; classLoader = AndroidNClassLoader.inject(loader, application); &#125; //because in dalvik, if inner class is not the same classloader with it wrapper class. //it won't fail at dex2opt if (Build.VERSION.SDK_INT &gt;= 23) &#123; V23.install(classLoader, files, dexOptDir); &#125; else if (Build.VERSION.SDK_INT &gt;= 19) &#123; V19.install(classLoader, files, dexOptDir); &#125; else if (Build.VERSION.SDK_INT &gt;= 14) &#123; V14.install(classLoader, files, dexOptDir); &#125; else &#123; V4.install(classLoader, files, dexOptDir); &#125; //install done sPatchDexCount = files.size(); Log.i(TAG, "after loaded classloader: " + classLoader + ", dex size:" + sPatchDexCount); if (!checkDexInstall(classLoader)) &#123; //reset patch dex SystemClassLoaderAdder.uninstallPatchDex(classLoader); throw new TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL); &#125; &#125; &#125; 可以看到 Tinker 对不同系统版本分开做了处理,这里我们就看使用最广泛的 Android4.4到 Android5.1.123456789101112131415161718192021222324252627/** * Installer for platform versions 19. */ private static final class V19 &#123; private static void install(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException &#123; /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ Field pathListField = ShareReflectUtil.findField(loader, "pathList"); Object dexPathList = pathListField.get(loader); ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); ShareReflectUtil.expandFieldArray(dexPathList, "dexElements", makeDexElements(dexPathList, new ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory, suppressedExceptions)); if (suppressedExceptions.size() &gt; 0) &#123; for (IOException e : suppressedExceptions) &#123; Log.w(TAG, "Exception in makeDexElement", e); throw e; &#125; &#125; &#125; V19.install()中先通过反射获取 BaseDexClassLoader 中的 dexPathList,然后调 用了 ShareReflectUtil.expandFieldArray().值得一提的是微信对异常的处理很细致, 用 List接收 dexElements数组中每一个 dex加载抛出的异常而不是笼统 的抛出一个大异常. 接着跟到 shareutil包下的 ShareReflectUtil类,12345678910111213141516171819202122/** * Replace the value of a field containing a non null array, by a new array containing the * elements of the original array plus the elements of extraElements. * * @param instance the instance whose field is to be modified. * @param fieldName the field to modify. * @param extraElements elements to append at the end of the array. */ public static void expandFieldArray(Object instance, String fieldName, Object[] extraElements) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException &#123; Field jlrField = findField(instance, fieldName); Object[] original = (Object[]) jlrField.get(instance); Object[] combined = (Object[]) Array.newInstance(original.getClass().getComponentType(), original.length + extraElements.length); // NOTE: changed to copy extraElements first, for patch load first System.arraycopy(extraElements, 0, combined, 0, extraElements.length); System.arraycopy(original, 0, combined, extraElements.length, original.length); jlrField.set(instance, combined); &#125; 这里的入参fieldName正是上一步中的” dexElements” ,在这么不起眼的一 个工具类中终于找到了 Dex流派的核心方法 和其他Dex流框架的实现几乎一模一样,至此可以看到,虽然微信团队说的天花乱坠, 其本质仍然是用 dexElements中位置靠前的 Dex优先加载类来实现热修复: )但传统方法为避免不同dex 中类互相引用而报 unexpectedDEX 错引入了” 插桩 ” 的步骤,给每个类加上一行引用其他类的方法,这样导致第一次加载类时耗时变长.应 用启动时通常会加载大量类,所以对启动时间的影响很可观.Tinker 的亮点是通过全量 替换dex 的方式避免 unexpectedDEX,这样做所有的类自然都在同一个 dex 中.但这会带来补 丁包 dex过大的问题,由此微信自研 DexDiff算法取代传统的 BsDiff极大降低了补丁包 大小,又规避了运行性能问题又减小了补丁包大小,可以说是 Dex流派的一大进步. Robust美团的热更新方案Robust借鉴了AndroidStudio2.0版本开始提供的功能Instant Run 的实现,另辟蹊径又比上述两种流派在原理上更简单,但同样也有些难以克服的缺陷.Robust在编译阶段给每个类每个函数插入一段代码,例如123public long getIndex() &#123; return 100;&#125; 被处理成如下的实现:12345678public static ChangeQuickRedirect changeQuickRedirect; public long getIndex() &#123;if(changeQuickRedirect != null) &#123;//PatchProxy中封装了获取当前 className和methodName的逻辑，并在其//内部最终调用了 changeQuickRedirect 的对应函数if(PatchProxy.isSupport(new Object[0], this, changeQuickRedirect, false)) &#123;return ((Long)PatchProxy.accessDispatch(new Object[0], this, changeQuickRedirect, false)).longValue();&#125; &#125;return 100L; &#125; 每个 class都增加了个类型为 ChangeQuickRedirect的静态成员，而在每个方法前 都插入了使用 changeQuickRedirect 相关的逻辑，当 changeQuickRedirect 不为 null 时，可能会执行到 accessDispatch从而替换掉之前老的逻辑，达到 fix的目的。如果需将 getIndex 函数的返回值改为 return 106，那么对应生成的 patch，主 要包含两个 class:PatchesInfoImpl.java和 StatePatch.java。 PatchesInfoImpl.java:123456public class PatchesInfoImpl implements PatchesInfo &#123; public List&lt;PatchedClassInfo&gt; getPatchedClassesInfo() &#123;List&lt;PatchedClassInfo&gt; patchedClassesInfos = new ArrayList&lt;PatchedClassInfo&gt;();PatchedClassInfo patchedClass = new PatchedClassInfo("com.meituan.sample.d", StatePatch.class.getCanonicalName());patchedClassesInfos.add(patchedClass);return patchedClassesInfos; &#125;&#125; StatePatch.java:123456789101112public class StatePatch implements ChangeQuickRedirect &#123; @Overridepublic Object accessDispatch(String methodSignature, Object[] paramArrayOfObject) &#123; String[] signature = methodSignature.split(":");if (TextUtils.equals(signature[1], "a")) &#123;//long getIndex() -&gt; areturn 106; &#125;return null; &#125;@Overridepublic boolean isSupport(String methodSignature, Object[] paramArrayOfObject) &#123;String[] signature = methodSignature.split(":");if (TextUtils.equals(signature[1], "a")) &#123;//long getIndex() -&gt; areturn true; &#125;return false; &#125;&#125; 客户端拿到含有 PatchesInfoImpl.java和 StatePatch.java的 patch.dex后，用 DexClassLoader加载 patch.dex，反射拿到 PatchesInfoImpl.java这个 class。拿到后， 创建这个 class的一个对象。然后通过这个对象的 getPatchedClassesInfo函数，知道需 要 patch的 class为 com.meituan.sample.d(com.meituan.sample.State混淆后的 名字)，再反射得到当前运行环境中的 com.meituan.sample.d class，将其中的 changeQuickRedirect字段赋值为用 patch.dex中的 StatePatch.java这个 class new出来的对象。这就是打 patch 的主要过程。通过原理分析，其实 Robust 只是在正常的 使用 DexClassLoader，所以可以说这套框架是没有兼容性问题的这个实现方式的优点是简单、不涉及底层知识,所以易维护.修复能够立即生效无需重 启.但缺点也很明显,给每个类每个函数都插入一段代码将导致安装包体积大增,同时对运 行性能有影响.]]></content>
      <tags>
        <tag>热修复</tag>
        <tag>hook</tag>
        <tag>dex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[appveyor 自动化构建 hexo 博客失败]]></title>
    <url>%2F2018%2F05%2F07%2Fappveyor-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA-hexo-%E5%8D%9A%E5%AE%A2%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[因为之前是 appveyor 来自动构建我的博客的.至于怎么用 appveyor 构建 hexo 博客,可以移步Hexo的版本控制与持续集成 今天突然发现更的博客和相册没有在网站上面发现更新.就去 appveyor. 一看才知道 构建失败了.错误日志 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Build startedgit clone -q --depth=5 --branch=master https://github.com/lovexinforever/blog_src.git C:\projects\blog-srcgit checkout -qf 5b6eaa0b3536784eb24fc766ae22cf0e9f2da1fcRunning Install scriptsnode --versionv4.8.7npm --version2.15.11npm install&gt; fsevents@1.2.3 install C:\projects\blog-src\node_modules\fsevents&gt; node install&gt; nunjucks@3.1.2 postinstall C:\projects\blog-src\node_modules\nunjucks&gt; node postinstall-build.js srcnpm install hexo-cli -gnpm WARN engine hexo-fs@0.2.3: wanted: &#123;"node":"&gt;=6.9.0"&#125; (current: &#123;"node":"4.8.7","npm":"2.15.11"&#125;)npm WARN optional dep failed, continuing fsevents@1.2.3C:\Users\appveyor\AppData\Roaming\npm\hexo -&gt; C:\Users\appveyor\AppData\Roaming\npm\node_modules\hexo-cli\bin\hexohexo-cli@1.1.0 C:\Users\appveyor\AppData\Roaming\npm\node_modules\hexo-cli├── abbrev@1.1.1├── object-assign@4.1.1├── command-exists@1.2.6├── minimist@1.2.0├── tildify@1.2.0 (os-homedir@1.0.2)├── chalk@1.1.3 (escape-string-regexp@1.0.5, supports-color@2.0.0, ansi-styles@2.2.1, strip-ansi@3.0.1, has-ansi@2.0.0)├── bluebird@3.5.1├── resolve@1.7.1 (path-parse@1.0.5)├── hexo-fs@0.2.3 (escape-string-regexp@1.0.5, graceful-fs@4.1.11, chokidar@1.7.0)├── hexo-util@0.6.3 (html-entities@1.2.1, striptags@2.2.1, camel-case@3.0.0, cross-spawn@4.0.2, highlight.js@9.12.0)└── hexo-log@0.2.0 (hexo-bunyan@1.0.0)npm install hexo -savenpm WARN engine hexo@3.7.1: wanted: &#123;"node":"&gt;=6.9.0"&#125; (current: &#123;"node":"4.8.7","npm":"2.15.11"&#125;)hexo@3.7.1 node_modules\hexo└── hexo-cli@1.1.0 (chalk@1.1.3)npm install hexo-wordcount@2 --savehexo-wordcount@2.0.1 node_modules\hexo-wordcountnpm install hexo-generator-sitemap --savehexo-generator-sitemap@1.2.0 node_modules\hexo-generator-sitemap└── nunjucks@2.5.2npm install hexo-generator-baidu-sitemap --savenpm WARN deprecated ejs@1.0.0: Critical security bugs fixed in 2.5.5hexo-generator-baidu-sitemap@0.1.2 node_modules\hexo-generator-baidu-sitemap├── hexo-generator-baidu-sitemap@0.0.8└── ejs@1.0.0npm install hexo-generator-searchdb --savenpm WARN deprecated ejs@1.0.0: Critical security bugs fixed in 2.5.5hexo-generator-searchdb@1.0.8 node_modules\hexo-generator-searchdb├── striptags@3.1.1└── ejs@1.0.0hexo generateERROR Local hexo not found in C:\projects\blog-srcERROR Try running: 'npm install hexo --save'Command exited with code 2 刚开始以为要执行1npm install hexo --save 结果发现还是不行就仔细看了日志,发现1npm WARN engine hexo@3.7.1: wanted: &#123;"node":"&gt;=6.9.0"&#125; (current: &#123;"node":"4.8.7","npm":"2.15.11"&#125;) 原来是 版本升级问题, 是 hexo 的版本要 node.js&gt;=6的.于是就升级了 appveyor.yml.12environment: nodejs_version: "6" 在 environment 下面增加 nodejs 版本12install: - ps: Install-Product node $env:nodejs_version 在 install 第一行添加如上代码. 然后重新构建就 ok 了]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>持续集成</tag>
        <tag>版本管理</tag>
        <tag>CI</tag>
        <tag>AppVeyor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Geektool 使用 python + beautiful 实现抓取天气图标]]></title>
    <url>%2F2018%2F04%2F20%2FGeektool-%E4%BD%BF%E7%94%A8-python-beautiful-%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8F%96%E5%A4%A9%E6%B0%94%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[上篇文章 Geektool 使用 python+beautifulsoup 抓取天气显示 讲解了怎样爬取天气网站的天气.但是界面上显示宗师感觉不好看,想显示天气的图标,翻看了几个天气网站,并没有我满意的天气图标.于是就打算自己去做一个了. 开发思路首先上篇文章已经爬取到天气状态如晴朗,局部多云等. 由于也是刚刚弄,并不知道天气状态到底对应几个.目前也只是遇到三种,后面遇到的话再加下逻辑.然后根据天气状态下载对应的天气图标到计算机本地目录,最后用 geektool 显示本地图片. 更新一下天气状态脚本 脚本123456789101112131415161718192021222324252627282930#!/usr/bin/env python#-*- coding: UTF-8 -*- import sysreload(sys)sys.setdefaultencoding('utf-8')import urllibimport osfrom bs4 import BeautifulSoupimport reif __name__ == '__main__': resp=urllib.urlopen('https://weather.com/zh-CN/weather/today/l/5ef652409badc75c97292b401c6db8e8e55a3157f300dc0997bea96343e4a20a') soup=BeautifulSoup(resp,'html.parser') tagToday=soup.find('div',attrs=&#123;'class':'today_nowcard-phrase'&#125;) url='' if "晴朗" == tagToday.get_text(): url='https://raw.githubusercontent.com/lovexinforever/blog_back_up/master/blog_photos/20101027235021742.png' elif "局部多云" == tagToday.get_text(): url='https://raw.githubusercontent.com/lovexinforever/blog_back_up/master/blog_photos/20101027235020501.png' elif "大部多云" == tagToday.get_text(): url='https://raw.githubusercontent.com/lovexinforever/blog_back_up/master/blog_photos/20101027235019364.png' elif "小雨" == tagToday.get_text(): url='https://raw.githubusercontent.com/lovexinforever/blog_back_up/master/blog_photos/20101027235021677.png' elif "多云" == tagToday.get_text(): url="https://raw.githubusercontent.com/lovexinforever/blog_back_up/master/blog_photos/20101027235021422.png" elif "雨" == tagToday.get_text(): url="https://raw.githubusercontent.com/lovexinforever/blog_back_up/master/blog_photos/20101027235021502.png" else: url='https://raw.githubusercontent.com/lovexinforever/blog_back_up/master/blog_photos/20101027235020136.png' urllib.urlretrieve(url, '/tmp/weather.png') print(tagToday.get_text()) url 对应相应状态的 天气图标地址.目前我只遇到过这三种,后面遇到其他的再添加对应的状态.更新一下天气状态. 相应的天气图标可以在我的 github 上面下载. 天气图标]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>geektool</tag>
        <tag>天气</tag>
        <tag>beautifulsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Geektool 使用 python+beautifulsoup 抓取天气显示]]></title>
    <url>%2F2018%2F04%2F19%2FGeektool-%E4%BD%BF%E7%94%A8-python-%E6%8A%93%E5%8F%96%E5%A4%A9%E6%B0%94%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[闲来无事,就想着捣鼓捣鼓电脑,想在电脑桌面实时显示天气状况.就用 geektool + python + beautifulsoup 写了一个抓取天气网站的脚本来显示. 效果先看实现出来的效果 实现思路用 python 去爬取天气网站的内容,解析抓取到的内容,提取今日的温度信息和天气天气,然后显示在 geektool 上面 天气网站我这边选用的是 weather channel在网站里面把地址切换到你想抓取的地区.如图,可以看到实时温度现在1&lt;div class="today_nowcard-temp"&gt;&lt;span class=""&gt;25&lt;sup&gt;°&lt;/sup&gt;&lt;/span&gt;&lt;/div&gt; 所以我们只要抓取 class为 today_nowcard-temp的标签,获取标签下面的文本内容 就是我们想要的温度信息.同理天气状况 只要抓取1&lt;div class="today_nowcard-phrase"&gt;晴朗&lt;/div&gt; 的内容 准备开发使用 beautifulsoup 去抓取页面内容.所以我们需要安装.由于 geektool 使用python 的版本是 2.7.10的.所以我们要在 python2.7里面安装 beautifulsoup.安装命令1python -m pip install beautifulsoup4 然后查看有没有安装成功1python -m pip list 如果有显示 beautifulsoup4的包就是安装成功了.如果没有的话就没有安装成功. 如果你那么不幸运没有安装成功.就只能去 beautifulsoup download 去下载源码.然后切换到beautifulsoup的setup.py 的命令目录执行12python setup.py buildpython setup.py install 执行成功后在查看安装的包,就看到安装成功了. 执行脚本1234567891011121314#!/usr/bin/env python#-*- coding: UTF-8 -*- import sysreload(sys)sys.setdefaultencoding('utf-8')import urllibimport osfrom bs4 import BeautifulSoupimport reif __name__ == '__main__': resp=urllib.urlopen('https://weather.com/zh-CN/weather/today/l/5ef652409badc75c97292b401c6db8e8e55a3157f300dc0997bea96343e4a20a') soup=BeautifulSoup(resp,'html.parser') tagToday=soup.find('div',attrs=&#123;'class':'today_nowcard-temp'&#125;) print(tagToday.span.get_text()) 可以看到 geektool 输出温度信息了,然后在 geektool 里面修改样式就好了天气信息同理]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>geektool</tag>
        <tag>天气</tag>
        <tag>beautifulsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义view 之激活码验证码输入框]]></title>
    <url>%2F2017%2F12%2F29%2F%E8%87%AA%E5%AE%9A%E4%B9%89view-%E4%B9%8B%E6%BF%80%E6%B4%BB%E7%A0%81%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%2F</url>
    <content type="text"><![CDATA[前两天接了个项目,项目中需要自定义一个激活码输入框,类似于滴滴打车那种正方形输入框.然后思考了一下怎么去做这个输入框.终于在今天搞定了.输入框接收 自定义输入框的数量,输入框的宽度,输入框之间的分割线,输入框文字颜色,输入框文字大小,输入框获取焦点的边框,每个输入框的文字个数以及输入框的透明度 效果展示 开发思路我们需要通过EditText控件接受我们的输入，界面中明显是不能看到这个控件的，所以我们需要将这个控件给设置透明。然后将接受到的输入内容设置给我们的TextView。为了满足正方形的样式，只需要给TextView设置一个背景即可。在开发过程中，我们发现验证码的个数不是固定的，有4位数的，也有6位数的。为了实现低耦合的复用性。我们需要一个自定义的属性来满足这个要求。其他具体的思路将会在具体实现的时候讲。 实现 组合控件的布局实现 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:id="@+id/container_et" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_centerInParent="true" android:gravity="center_vertical" android:orientation="horizontal" android:showDividers="middle"&gt; &lt;/LinearLayout&gt; &lt;EditText android:id="@+id/et" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@android:color/transparent" android:inputType="number" /&gt;&lt;/RelativeLayout&gt; 这的LinearLayout用来存放TextVeiw ,android:showDividers=”middle”来设定我们的间隔的方式。 设计自定义属性 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="ActivationCodeView"&gt; &lt;attr name="icv_et_number" format="integer" /&gt; &lt;!--输入框的宽度--&gt; &lt;attr name="icv_et_width" format="dimension|reference" /&gt; &lt;!--输入框之间的分割线--&gt; &lt;attr name="icv_et_divider_drawable" format="reference" /&gt; &lt;!--输入框文字颜色--&gt; &lt;attr name="icv_et_text_color" format="color|reference" /&gt; &lt;!--输入框文字大小--&gt; &lt;attr name="icv_et_text_size" format="dimension|reference" /&gt; &lt;!--输入框获取焦点时边框--&gt; &lt;attr name="icv_et_bg_focus" format="reference" /&gt; &lt;!--输入框没有焦点时边框--&gt; &lt;attr name="icv_et_bg_normal" format="reference" /&gt; &lt;!--每个输入框中的文字个数 --&gt; &lt;attr name="icv_text_count_num" format="integer" /&gt; &lt;!--输入框背景透明度 --&gt; &lt;attr name="icv_text_bg_alpha" format="integer" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 注释已经很清楚了，就不再解释了。 获取自定义属性 12345678910111213141516171819202122232425262728293031323334353637383940/** * 初始化 * @param context * @param attrs * @param defStyleAttr */ private void init(Context context, AttributeSet attrs, int defStyleAttr) &#123; LayoutInflater.from(context).inflate(R.layout.layout_activation_code, this); mContainerLl = (LinearLayout) this.findViewById(R.id.container_et); mInputEt = (EditText) this.findViewById(R.id.et); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ActivationCodeView, defStyleAttr, 0); mEtNumber = typedArray.getInteger(R.styleable.ActivationCodeView_icv_et_number, 1); mTvCountNumber = typedArray.getInteger(R.styleable.ActivationCodeView_icv_text_count_num, 1); mAlpha = typedArray.getInteger(R.styleable.ActivationCodeView_icv_text_bg_alpha,255); mEtWidth = typedArray.getDimensionPixelSize(R.styleable.ActivationCodeView_icv_et_width, 42); mEtDividerDrawable = typedArray.getDrawable(R.styleable.ActivationCodeView_icv_et_divider_drawable); mEtTextSize = typedArray.getDimensionPixelSize(R.styleable.ActivationCodeView_icv_et_text_size, 16); mEtTextColor = typedArray.getColor(R.styleable.ActivationCodeView_icv_et_text_color, Color.BLACK); mEtBackgroundDrawableFocus = typedArray.getDrawable(R.styleable.ActivationCodeView_icv_et_bg_focus); mEtBackgroundDrawableNormal = typedArray.getDrawable(R.styleable.ActivationCodeView_icv_et_bg_normal); //释放资源 typedArray.recycle(); // 当xml中未配置时 这里进行初始配置默认图片 if (mEtDividerDrawable == null) &#123; mEtDividerDrawable = context.getResources().getDrawable(R.drawable.shape_divider_identifying); &#125; if (mEtBackgroundDrawableFocus == null) &#123; mEtBackgroundDrawableFocus = context.getResources().getDrawable(R.drawable.shape_icv_et_bg_focus); &#125; if (mEtBackgroundDrawableNormal == null) &#123; mEtBackgroundDrawableNormal = context.getResources().getDrawable(R.drawable.shape_icv_et_bg_normal); &#125; initUI(); &#125; 初始化 TextView 1234567891011121314151617181920212223242526272829303132//初始化TextView private void initTextViews(Context context, int etNumber, int etWidth, Drawable etDividerDrawable, float etTextSize, int etTextColor) &#123; // 设置 editText 的输入长度 mInputEt.setCursorVisible(false);//将光标隐藏 mInputEt.setFilters(new InputFilter[]&#123;new InputFilter.LengthFilter(etNumber)&#125;); //最大输入长度 // 设置分割线的宽度 if (etDividerDrawable != null) &#123; etDividerDrawable.setBounds(0, 0, etDividerDrawable.getMinimumWidth(), etDividerDrawable.getMinimumHeight()); mContainerLl.setDividerDrawable(etDividerDrawable); &#125; mTextViews = new TextView[etNumber]; for (int i = 0; i &lt; mTextViews.length; i++) &#123; TextView textView = new TextView(context); textView.setTextSize(etTextSize); textView.setTextColor(etTextColor); textView.setWidth(etWidth); textView.setHeight(etWidth); if (i == 0) &#123; textView.setBackgroundDrawable(mEtBackgroundDrawableFocus); &#125; else &#123; textView.setBackgroundDrawable(mEtBackgroundDrawableNormal); &#125; //設置透明度 textView.getBackground().setAlpha(mAlpha); textView.setGravity(Gravity.CENTER); textView.setFocusable(false); mTextViews[i] = textView; &#125; &#125; 这里动态生成TextView 具体实现 注释很清楚，需要注意一点的是 textView.setFocusable(false); 不然在页面中TextView会获取焦点有一个 光标。用一个数组来存放 TextView。 填充盛放TextView的 LinerLayout 12345private void initEtContainer(TextView[] mTextViews) &#123; for (int i = 0; i &lt; mTextViews.length; i++) &#123; mContainerLl.addView(mTextViews[i]); &#125; &#125; 处理我们的输入事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private class ActivationCodeTextWatcher implements TextWatcher &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; &#125; @Override public void afterTextChanged(Editable editable) &#123; String inputStr = editable.toString(); if (inputStr != null &amp;&amp; !inputStr.equals("")) &#123; setText(inputStr); mInputEt.setText(""); &#125; &#125; &#125; // 监听删除按键 mInputEt.setOnKeyListener(new OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_DEL &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) &#123; onKeyDelete(); return true; &#125; return false; &#125; &#125;); // 给TextView 设置文字 private void setText(String inputContent) &#123; for (int i = 0; i &lt; mTextViews.length; i++) &#123; TextView tv = mTextViews[i]; if (tv.getText().toString().trim().equals("") || tv.getText().toString().length() &lt; mTvCountNumber) &#123; tv.setText(tv.getText().toString() + inputContent); // 添加输入完成的监听 if (inputCompleteListener != null) &#123; inputCompleteListener.inputComplete(); &#125; //光标跳转到下一个 if(tv.getText().toString().length() == mTvCountNumber) &#123; tv.setBackgroundDrawable(mEtBackgroundDrawableNormal); if (i &lt; mEtNumber - 1) &#123; mTextViews[i + 1].setBackgroundDrawable(mEtBackgroundDrawableFocus); &#125; &#125; break; &#125; &#125; &#125; // 监听删除 private void onKeyDelete() &#123; for (int i = mTextViews.length - 1; i &gt;= 0; i--) &#123; TextView tv = mTextViews[i]; if (!tv.getText().toString().trim().equals("")) &#123; tv.setText(tv.getText().subSequence(0,tv.getText().length()-1)); // 添加删除完成监听 if (inputCompleteListener != null) &#123; inputCompleteListener.deleteContent(); &#125; tv.setBackgroundDrawable(mEtBackgroundDrawableFocus); if (i &lt; mEtNumber - 1) &#123; mTextViews[i + 1].setBackgroundDrawable(mEtBackgroundDrawableNormal); &#125; break; &#125; &#125; &#125; 提供给外界的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 获取输入文本 * * @return string */ public String getInputContent() &#123; StringBuffer buffer = new StringBuffer(); for (TextView tv : mTextViews) &#123; buffer.append(tv.getText().toString().trim()); &#125; return buffer.toString(); &#125; /** * 删除输入内容 */ public void clearInputContent() &#123; for (int i = 0; i &lt; mTextViews.length; i++) &#123; if (i == 0) &#123; mTextViews[i].setBackgroundDrawable(mEtBackgroundDrawableFocus); &#125; else &#123; mTextViews[i].setBackgroundDrawable(mEtBackgroundDrawableNormal); &#125; mTextViews[i].setText(""); &#125; &#125; /** * 设置输入框个数 * @param etNumber */ public void setEtNumber(int etNumber) &#123; this.mEtNumber = etNumber; mInputEt.removeTextChangedListener(mTextWatcher); mContainerLl.removeAllViews(); initUI(); &#125; /** * 获取输入的位数 * * @return int */ public int getEtNumber() &#123; return mEtNumber; &#125; // 输入完成 和 删除成功 的监听 private InputCompleteListener inputCompleteListener; public void setInputCompleteListener(InputCompleteListener inputCompleteListener) &#123; this.inputCompleteListener = inputCompleteListener; &#125; public interface InputCompleteListener &#123; void inputComplete(); void deleteContent(); &#125; 下载附上 github 下载地址 ActivationCodeView]]></content>
      <categories>
        <category>Technology</category>
        <category>Journal</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>激活码</tag>
        <tag>验证码</tag>
        <tag>自定义输入框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发 自定义跑马灯 TextView]]></title>
    <url>%2F2017%2F11%2F14%2FAndroid-%E5%BC%80%E5%8F%91-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%91%E9%A9%AC%E7%81%AF-TextView%2F</url>
    <content type="text"><![CDATA[在项目开发中,有次需要用到跑马灯,使用了系统自带的跑马灯,发现会有点问题.然后就考虑重写了一个跑马灯 textview.主要思路是 自定义一个画笔工具,自己画出 textview 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126public class MarqueeTextView extends View &#123; private static String TAG = MarqueeTextView.class.getSimpleName(); private String mContent; private ValueAnimator mAnimator; private Paint mPaint; private int mOffset; private int mBaseLine; private Rect mTargetRect; private int mTextWidth = 0; public MarqueeTextView(Context context) &#123; super(context); init(); &#125; public MarqueeTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public MarqueeTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPaint = new Paint(); mPaint.setTextSize(getContext().getResources().getDimension(R.dimen.sp_15)); mPaint.setColor(Color.RED); mPaint.setTextAlign(Paint.Align.LEFT); mPaint.setAntiAlias(true); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mContent == null) &#123; super.onMeasure(widthMeasureSpec,heightMeasureSpec); return; &#125; Paint.FontMetricsInt fontMetrics = mPaint.getFontMetricsInt(); int height = fontMetrics.bottom - fontMetrics.top + getPaddingBottom() + getPaddingTop(); setMeasuredDimension(widthMeasureSpec, MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY)); int top = getPaddingTop(); int bottom = top + fontMetrics.bottom - fontMetrics.top; int left = getPaddingLeft() + mOffset; int right = left + mTextWidth; if (mTargetRect == null) &#123; mTargetRect = new Rect(); &#125; mTargetRect.set(left, top, right, bottom); mBaseLine = (mTargetRect.bottom + mTargetRect.top - fontMetrics.bottom - fontMetrics.top) / 2; mAnimator.cancel(); if (mTextWidth &gt; getMeasuredWidth()) &#123; mAnimator.start(); &#125; &#125; @Override protected void onWindowVisibilityChanged(int visibility) &#123; super.onWindowVisibilityChanged(visibility); if(visibility == View.VISIBLE)&#123; start(); &#125;else&#123; cancel(); &#125; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mContent == null || mTargetRect == null) &#123; return; &#125; mTargetRect.left = getPaddingLeft() + mOffset; mTargetRect.right = mTargetRect.left + mTextWidth; canvas.drawText(mContent, mTargetRect.left, mBaseLine, mPaint); &#125; public void setText(String text) &#123; mContent = text; mTextWidth = (int) (mPaint.measureText(mContent, 0, mContent.length())+1); if(null == mAnimator)&#123; mAnimator = ValueAnimator.ofFloat(0, mTextWidth); mAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; mOffset -= 2; if (mOffset &lt; -mTextWidth) &#123; mOffset = getWidth(); &#125; invalidate(); &#125; &#125;); mAnimator.setRepeatCount(ValueAnimator.INFINITE); mAnimator.setRepeatMode(ValueAnimator.REVERSE); //5.为ValueAnimator设置目标对象并开始执行动画 mAnimator.setTarget(this); mAnimator.setDuration((long) (mTextWidth)); &#125; &#125; public void start()&#123; if(null != mAnimator &amp;&amp; mTextWidth &gt; getMeasuredWidth())&#123; mAnimator.start(); &#125; &#125; public void cancel()&#123; if(null != mAnimator &amp;&amp; mTextWidth &gt; getMeasuredWidth())&#123; mAnimator.cancel(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Technology</category>
        <category>Journal</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>跑马灯</tag>
        <tag>自定义textview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git怎样删除未监视的文件untracked files]]></title>
    <url>%2F2017%2F10%2F31%2Fgit%E6%80%8E%E6%A0%B7%E5%88%A0%E9%99%A4%E6%9C%AA%E7%9B%91%E8%A7%86%E7%9A%84%E6%96%87%E4%BB%B6untracked-files%2F</url>
    <content type="text"><![CDATA[使用 git 中 经常需要还原文件. 如果是文件是 untracked files.则我们用 git clean 来还原12345678910111213# 删除 untracked filesgit clean -f # 连 untracked 的目录也一起删掉git clean -fd # 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）git clean -xfd # 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删git clean -nxfdgit clean -nfgit clean -nfd 如果文件是 tracked files则我们用 git checkout来还原12345#还原指定文件git checkout files#全部还原git checkout .]]></content>
      <categories>
        <category>Technology</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>untracked</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七阶魔方中心块合并公式(含五阶魔方)]]></title>
    <url>%2F2017%2F10%2F26%2F%E4%B8%83%E9%98%B6%E9%AD%94%E6%96%B9%E4%B8%AD%E5%BF%83%E5%9D%97%E5%90%88%E5%B9%B6%E5%85%AC%E5%BC%8F-%E5%90%AB%E4%BA%94%E9%98%B6%E9%AD%94%E6%96%B9%2F</url>
    <content type="text"><![CDATA[分享一下 七阶魔方5乘5中心块拼法. 确实,一条一条拼中心实在不是个办法,我们只追求最笨,但最可靠的方法.如图1的红框内的中心,数字代表我们拼中心块的顺序,仔细观察一下,共5步,前后次序千万不能颠倒了. 咱们的思路是：先完成中间的3×3的中心块,再完成周围的5×5的中心块.而且这套公式不会破坏彼此的拼合（口诀：从三到五,先角后棱）.下面如果没有特殊说明,做公式时把魔方就放成图中那样,对着自己做公式. 一、3×3中心块：先完成序号1,再完成序号2. 1、序号1的公式：如图4,做公式：TR U TR’ U TR U2 TR’这样就完成一块,每一块都这样拼. 2、序号2公式,如图3,做公式：TR’ F’ MR’ F TR F’ MR也一样,每块都这样拼.以上就完成了3×3的中心块. 二、5×5中心块：按照序号345来拼. 1、序号3的公式其实和序号1的一样,公式套用7阶的写法很复杂,由于此公式在使用中不用7阶专用公式,因此你可以套用五阶的公式来做：TR U TR’ U TR U2 TR’这样就把所有的序号3给还原了. 2、序号4是最难处理的一步,因为这里涉及到左右两种镜像块,这需要你运用你的空间转换思维能力来还原,必须懂得变通才行,方法主要是参考序号2的公式,虽然有两种块,但都能按照“对应右面缺口”的方法来进行.如图2,把需要拼的绿色块放到相应位置,其目的是要拼到下方的红色方格内. 3、序号5就简单多了,完全参考序号2的公式就能全部解决：TR’ F’ MR’ F TR F’ MR （TR也是右边两层一起转,MR同样是右边第二层单独转）这样把所有的序号5也还原了. PS：序号4,你可以自行多研究研究,我真的好久不玩了,这套中心的拼法可以套用任何更高阶的魔方（N阶）,并且不会破坏任何联结,只要对应住缺口摆成图中的样子即可.另外图1中的蓝色部分其实也可以无视先后次序,关键在于理解.]]></content>
      <categories>
        <category>Entertainment</category>
        <category>Cube</category>
      </categories>
      <tags>
        <tag>魔方</tag>
        <tag>七阶</tag>
        <tag>五阶</tag>
        <tag>中心块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-冒泡排序]]></title>
    <url>%2F2017%2F10%2F16%2Fpython-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[之前文章中介绍了怎样用 hexo + next 生成相册.由于相册图片命名方式为 yyyy-MM-dd_des.jpg 形式,导致在取9月和10月的时候,会发生顺序上的错误.这是由于10的排序比9的排序靠前.所以就想到了用冒泡排序来解决这个问题 冒泡排序的时间复杂度冒泡排序的时间复杂度是O(N^2) 冒泡排序的思想每次比较两个相邻的元素, 如果他们的顺序错误就把他们交换位置 比如有五个数: 12, 35, 99, 18, 76, 从大到小排序, 对相邻的两位进行比较 第一趟: 第一次比较: 35, 12, 99, 18, 76 第二次比较: 35, 99, 12, 18, 76 第三次比较: 35, 99, 18, 12, 76 第四次比较: 35, 99, 18, 76, 12 经过第一趟比较后, 五个数中最小的数已经在最后面了, 接下来只比较前四个数, 依次类推 第二趟: 99, 35, 76, 18, 12 第三趟: 99, 76, 35, 18, 12 第四趟: 99, 76, 35, 18, 12 比较完成 冒泡排序原理每一趟只能将一个数归位, 如果有n个数进行排序,只需将n-1个数归位, 也就是说要进行n-1趟操作(已经归位的数不用再比较) 12345678910111213#!/usr/bin/env python# coding:utf-8def bubbleSort(nums): for i in range(len(nums)-1): # 这个循环负责设置冒泡排序进行的次数 for j in range(len(nums)-i-1): # ｊ为列表下标 if nums[j] &gt; nums[j+1]: nums[j], nums[j+1] = nums[j+1], nums[j] return numsnums = [5,2,45,6,8,2,1]print bubbleSort(nums) 缺点冒泡排序解决了桶排序浪费空间的问题, 但是冒泡排序的效率特别低 引用打开 tool.py,添加冒泡排序方法12345678910def bubble(bubbleList): listLength = len(bubbleList) while listLength &gt; 0: for i in range(listLength - 1): # 这个循环负责设置冒泡排序进行的次数 for j in range(listLength-i-1): # ｊ为列表下标 if(bubbleList[j].get('arr').get('year') == bubbleList[j+1].get('arr').get('year')): if bubbleList[j].get('arr').get('month') &lt; bubbleList[j+1].get('arr').get('month'): bubbleList[j], bubbleList[j+1] = bubbleList[j+1], bubbleList[j] return bubbleList 在 handle_photo 中引用 bubble在 list_info.reverse() # 翻转 下面添加 bubble(list_info) 到此就完成了 10月排在9月前面的工作.]]></content>
      <categories>
        <category>Technology</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>排序</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器和选取方法(二)]]></title>
    <url>%2F2017%2F09%2F27%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E9%80%89%E5%8F%96%E6%96%B9%E6%B3%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[上一篇文章jQuery选择器和选取方法(一)讲解了 JQuery 选择器.今天将说下选择的选取方法. 选取方法除了$()函数支持的选择器语法，jQuery还定义了一些选取方法。本章中我们已看到过的大部分jQuery方法都是在选中元素上执行某种操作。选取方法不一样:它们会修改选中元素集，对其进行提取、扩充或仅作为新选取操作的起点。 本节描述这些选取方法。你会注意到这些选取方法中的多数提供的功能与选择器语法的功能是一样的。 提取选中元素最简单的方式是按位置提取。first()返回的jQuery对象仅包含选中元素中的第一个，last()返回的jQuery对象则只 包含最后一个元素。更通用的是，eq()方法返回物Query对象只包含指定序号的单个选中元素。(在jQuery 1.4中，负序号也是允许的，会从选区的末尾开始计数。)注意这些方法返回的jQuery对象只含有一个元素。这与常见的数组序号是不一样的，数组序号返 回的单一元素没有经过jQuery包装:123456var paras=$("p");paras.first() //仅选取第一个&lt;p&gt;元素paras.last() //仅选取最后一个&lt;P&gt;paras.eq(1) //选取第二个&lt;P&gt;paras.eq(-2) //选取倒数第二个&lt;P&gt;paras[1] //第二个&lt;P&gt;元素自身 通过位置提取选区更通用的方法是slice()o jQuery的slice()方法与Array.slice()方法类似:前者接受开始和结束序号(负序号会从结尾处计算)，返回的jQuery对象包含 从开始到结束序号(但不包含结束序号)处的元素集。如果省略结束序号，返回的对象会包含从开始序号起的所有元素:12$("p").slice(2,5) //选取第3个、第4个和第5个&lt;P&gt;元素$("div").slice(-3) //选取最后3个&lt;div&gt;元素 filter()是通用的选区过滤方法，有3种调用方式: 传递选择器字符串给filter()，它会返回一}jQuery对象，仅包含也匹配该选择器的选中元素。 传递另一个jQuery对象给filter()，它会返回一个新的jQuery对象，该对象包含这两们Query对象的交集。也可以传递元素数组甚至单一文档元素给filter()。 传递判断函数给filter()，会为每一个匹配元素调用该函数，filter()则返回一个jQuery对象，仅包含判断函数为true(或任意真值)的元素。在调用判断函数时，this值为当前元素，参数是元素序号。 123$("div").filter(".note") //与$("div.note")一样$("div").filter($(".note")) //与$("div.note")一样$("div").filter(function(idx)&#123;return idx%2 == 0&#125;) //与$("div:even")一样 not()方法与filter()一样，除了含义与filter()相反。如果传递选择器字符串给not()它会返回一个新的jQuery对象，该 对象只包含不匹配该选择器的元素。如果传递jQuery对象、元素数组或单一元素给not()，它会返回除了显式排除的元素之外的所有选中元素。如果传递 判断函数给not()，该判断函数的调用就与在filter()中一样，只是返回的jQuery对象仅包含那些使得判断函数返回false或其他假值的元 素:1$("div").not("#header, #footer"); //除了两个特殊元素之外的所有元素 在jQuery 1.4中，提取选区的另一种方式是has()方法。如果传入选择器，has()会返回一个新的jQuery对象，仅包含有子孙元素匹配该选择器的选中元素。如果传入文档元素给has()，它会将选中元素集调整为那些是指定元素祖先节点的选中元素:1$("p").has("a[href]") //包含链接的段落 add()方法会扩充选区，而不是对其进行过滤或提取。可以将传给$()函数的任何参数(除了函数)照样传给add()方法。add()方法会返回 原来的选中元素，加上传给$()函数的那些参数所选中(或创建)的那些元素。add()会移除重复元素，并对该组合选区进行排序，以便里面的元素按照文档 中的顺序排列:123456//选取所有&lt;div&gt;和所有&lt;P&gt;元素的等价方式$("div, p") //使用选择器组$("div").add(p) //给add()传入选择器$("div").add($("p")) //给add()传入jQuery对象var paras = document.getElementsByTagName("p"); //类数组对象$("div").add(paras); //给add()传入元素数组 将选中元素集用做上下文上面描述的filter(). add()、和not()方法会在各自的选中元素集上执行交集、并集和差集运算。jQuery还定义一些其他选取方法可将当前选中元素集作为上下文来使 用。对选中的每一个元素，这些方法会使用该选中元素作为上下文或起始点来得到新的选中元素集，然后返回一个新的jQuery对象，包含所有新的选中元素的 并集。与add()方法类似，会移除重复元素并进行排序，以便元素会按照在文档中出现的顺序排列好。 该类别选取方法中最通用的是find()。它会在每一个当前选中元素的子孙元素中寻找与指定选择器字符串匹配的元素，然后它返回一个新的 jQuery对象来代表所匹配的子孙元素集。注意这些新选中的元素不会并入已存在的选中元素集中。同时注意find()和filter()不 同，filter()不会选中新元素，只是简单地将当前选中的元素集进行缩减:1$("div").find("p") //在中查找元素，与$("div p")相同 该类别中的其他方法返回新的jQuery对象，代表当前选中元素集中每一个元素的子元素、兄弟元素或父元素。大部分都接受可选的选择器字符串作为参数。不传入选择器时，它们会返回所有子元素、兄弟元素或父元素。传入选择器时，它们会过滤元素集，仅返回匹配的。 children()方法返回每一个选中元素的直接子元素，可以用可选的选择器参数进行过滤:123//寻找id为"header"和"footer"元素的子节点元素中的所有&lt;span&gt;元素//与$("#header&gt;span, #footer&gt;span")相同$("#header, #footer").children("span") contents()方法与children()方法类似，不同的是它会返回每一个元素的所有子节点，包括文本节点。如果选中元素集中 有&lt;iframe&gt;元素，contents()还会返回该&lt;iframe&gt;内容的文档对象。注意contents()不接受可选 的选择器字符串参数—因为它返回的文档节点不完全是元素，而选择器字符串仅用来描述元素节点。next()和prev()方法返回每一个选中元素的下一个和上一个兄弟元素(如果有的话)。如果传入了选择器，会只选中匹配该选择器的兄弟元素:12$("h1").next("p") //与$("h1+p")相同$("h1").prev() //&lt;h1&gt;元素前面的兄弟元素 nextAll()和prevAll()返回每一个选中元素前面或后面的所有兄弟元素(如果有的话)。siblings()方法则返回每一个选中元素的所有兄弟元素(选中元素本身不是自己的兄弟元素)。如果给这些方法传人选择器，则只会返回匹配的兄弟元素:12$("#footer").nextAll("p") //紧跟#footer元素的所有&lt;P&gt;兄弟元素$("#footer").prevAll() //#footer元素前面的所有兄弟元素 恢复到之前的选中元素集为了实现方法的链式调用，很多jQuery对象的方法最后都会返回调用对象。然而本节讲述的方法都返回新的jQuery对象。可以链式调用下去，但必须清晰地意识到，在链式调用的后面所操作的元素集，可能已经不是该链式调用开始时的元素集了。 实际情况还要复杂些。当这里所描述的选取方法在创建或返回一个新的ejQuery对象时，它们会给该对象添加一个到它派生自的旧jQuery对象的 内部引用。这会创建一个jQuery对象的链式表或栈。end()方法用来弹出栈，返回保存的jQuery对象。在链式调用中调用end()会将匹配元素 集还原到之前的状态。考虑以下代码:123456789101112//寻找所有&lt;div&gt;元素，然后在其中寻找&lt;P&gt;元素//高亮显示&lt;P&gt;元素，然后给&lt;div&gt;元素添加一个边框//首先，不使用链式调用var divs = $("div");var paras = div.find("p");paras.addClass("highlight");divs.css("border", "solid black 1px"); //下面展现如何使用链式调用来实现$("div").find("p").addClass("highlight").end().css("border", "solid black 1px");//还可以将操作调换顺序来避免调用end()$("div").css("border", "solid block 1px").find("p").addClass("highlight"); 如果想手动定义选中元素集，同时保持与end()方法的兼容，可以将新的元素集作为数组或类数组对象传递给push5tack()方法。指定的元素会成为新的选中元素，之前选中的元素集则会压入栈中，之后可以用end()方法还原它们:123var sel = $("div"); //选取所有&lt;div&gt;元素sel.pushStack(document.getElementsByTagName("p")); //修改为所有&lt;P&gt;元素sel.end(); //还原为&lt;div&gt;元素]]></content>
      <categories>
        <category>Technology</category>
        <category>HTML5</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>js</tag>
        <tag>JQuery</tag>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器和选取方法(一)]]></title>
    <url>%2F2017%2F09%2F26%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E9%80%89%E5%8F%96%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在 h5 开发中,JQuery 选择器经常用到,也尤其重要,用好选择器,能让你的开发事半功倍.下面是整理的 jquery 选择的使用和方法. jQuery选择器在CSS3选择器标淮草案定义的选择器语法中，jQuery支持相当完整的一套子集，同时还添加了一些非标准但很有用的伪类。注意:本节讲述的是 jQuery选择器。其中有不少选择器(但不是全部)可以在CSS样式表中使用。选择器语法有三层结构。你肯定已经见过选择器中最简单的形式。”#test”选取id属性为”test”的元素。”blockquote”选取文档中的所有&lt;blockquote&gt;元素，而”div.note” 则选取所有class属性为”note”的div元素。简单选择器可以组合成“组合选择器”，比如 “div.note&gt;p”和“blockquote i”，只要用组合字符做分隔符就行。简单选择器和组合选择器还可以分组成逗号分隔的列表。这种选择器组是传递给$()函数最常见的形式。在解释组合选择器 和选择器组之前，我们必须先了解简单选择器的语法。 简单选择器简单选择器的开头部分(显式或隐式地)是标签类型声明。例如，如果只对&lt;p&gt;元素感兴趣，简单选择器可以用“p”开头。如果选取的元素和标签名无关，则可以使用通配符“*”号来代替。如果选择器没有以标签名或通配符开头，则隐式含有一个通配符。 标签名或通配符指定了备选文档元素的一个初始集。在简单选择器中，标签类型声明之后的部分由零个或多个过滤器组成。过滤器从左到右应用，和书写顺序一致，其中每一个都会缩小选中元素集。下表列举了jQuery支持的过滤器。 标签描述#id匹配id属性为id的元素。在有效的}ITML文档中，永远不会出现多个元素拥有相同的ID，因此该过滤器通常作为独立选择器来使用.class匹配class属性(是一串被解析成用空格分隔的单词列表)含有class单词的所有元素[attr]匹配拥有attr属性(和值无关)的所有元素[attr=val]匹配拥有attr属性且值为val的所有元素[attr!=val]匹配没有attr属性、或attr属性的值不为val的所有元素((jQuery的扩展)[attr^=val]匹配attr属性值以val开头的元素[attr$=val]匹配attr属性值以val结尾的元素[attr*=val]匹配attr属性值含有val的元素[attr~=val]当其attr属性解释为一个由空格分隔的单词列表时，匹配其中包含单词val的元素。因此选择器“div.note”与“div [class~=note]”相同[attr|=val] 匹配正在动画中的元素，该动画是由jQuery产生的:button匹配&lt;button type=”button”&gt;和&lt;input type=”button”&gt;元素(jQuery的扩展):checkbox匹配&lt;input type=”checkbox”&gt;元素( jQuery的扩展)，当显式带有input标签前缀”input:checkbox”时，该过滤器更高效:checked匹配选中的input元素:contains(text)匹配含有指定text文本的元素(jQuery的扩展)。该过滤器中的圆括号确定了文本的范围—无须添加引号。被过滤的元素的文本是由textContent或innerText属性来决定的—这是原始文档文本，不带标签和注释:disabled匹配禁用的元素:empty匹配没有子节点、没有文本内容的元素:enabled匹配没有禁用的元素:eq(n)匹配基于文档顺序、序号从0开始的选中列表中的第n个元素(jQuery的扩展):even匹配列表中偶数序号的元素。由于第一个元素的序号是0，因此实际上选中的是第1个、第3个、第5个等元素(jQuery的扩展):file 匹配&lt;input type=”file”&gt;元素(jQuery的扩展):first匹配列表中的第一个元素。和“:eq(0)”相同(jQuery的扩展):first-child匹配的元素是其父节点的第一个子元素。注意:这与“:first”不同:gt(n)匹配基于文档顺序、序号从0开始的选中列表中序号大于n的元素( jQuery的扩展):has(sel)匹配的元素拥有匹配内嵌选择器sel的子孙元素:header匹配所有头元素:&lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;或&lt;h6&gt; (jQuery的扩展):hidden匹配所有在屏幕上不可见的元素:大体上可以认为这些元素的offsetWidth和offsetHeight为0:image匹配&lt;input type=”image”&gt;元素。注意该过滤器不会匹配&lt;img&gt;元素( jQuery的扩展):input匹配用户输入元素:&lt;input&gt;, &lt;textarea&gt;, &lt;select&gt;和&lt;button&gt;:last匹配选中列表中的最后一个元素:last-child匹配的元素是其父节点的最后一个子元素。注意:这与“:last”不同:lt(n)匹配基于文档顺序、序号从0开始的选中列表中序号小于n的元素:not(sel)匹配的元素不匹配内嵌选择器sel:nth(n)与“:eq(n)”相同:nth-child(n)匹配的元素是其父节点的第n个子元素。。可以是数值、单词even,单词odd或计算公式。 使用“:nth-child(even)”来选取那些在其父节点的子元素中排行第2或第4等序号的元素。使用“:nth-child(odd)”来选取那 些在其父节点的子元素中排行第1、第3等序号的元素。更常见的情况是，n是xn或x n+y这种计算公式，其中x和y是整数，n是字面量n。因此可以用nth-child(3n+1)来选取第1个、第4个、第7个等元素。注意该过滤器的序号是从1开始的，因此如果一个元素是其父节点的第一个子元素，会认为它是奇数元素，匹配的是3n+1，而不是3n。要和“:even以及“:odd”过滤器区分开来，后者匹配的序号是从0开始的。:odd匹配列表中奇数(从0开始)序号的元素。注意序号为1和3的元素分别是第2个和第4个匹配元素 注意:表中列举的部分选择器在圆括号中接受参数。例如，下面这个选择器选取的元素在其父节点的子元素中排行第1或第2等，只要它们含有“JavaScript”单词，就不包含元素。 1p:nth-child(3n+1): text (JavaScript):not(:has(a)) 通常来说，指定标签类型前缀，可以让过滤器的运行更高效。例如，不要简单使用”:radio”来选取单选框按钮，使用“input:radio”会 更好。ID过滤器是个例外，不添加标签前缀时它会更高效。例如，选择器“#address”通常比更明确的“form#address”更高效。 组合选择器使用特殊操作符或“组合符”可以将简单选择器组合起来，表达文档树中元素之间的关系。下表列举了jQuery支持的组合选择器。这些组合选择器与CSS3支持的组合选择器是一样的。下面是组合选择器的一些例子:1234"blockquote i" //匹配&lt;blockquote&gt;里的&lt;i&gt;元素"ol &gt; li" //&lt;1i&gt;元素是&lt;of&gt;的直接子元素"#output+*" //id="output"元素后面的兄弟元素"div.note &gt; h1+p" //紧跟&lt;h1&gt;的&lt;P&gt;元素，在&lt;div class="note"&gt;里面 注意组合选择器并不限于组合两个选择器:组合三个甚至更多选择器也是允许的。组合选择器从左到右处理。 选择器组传递给$()函数(或在样式表中使用)的选择器就是选择器组，这是一个逗号分隔的列表，由一个或多个简单选择器或组合选择器构成。选择器组匹配的元 素只要匹配该选择器组中的任何一个选择器就行。对我们来说，一个简单选择器也可以认为是一个选择器组。下面是选择器组的一些例子:1234"h1, h2,h3" //匹配&lt;h1&gt;, &lt;h2&gt;和&lt;h3&gt;元素"#p1, #p2, #p3" //匹配id为p1, p2或p3的元素"div.note, p.note" //匹配class="note"的&lt;div&gt;和&lt;P&gt;元素"body&gt;p,div.note&gt;p" //&lt;body&gt;和&lt;div class="note"&gt;的&lt;P&gt;子元素 注意:CSS和jQuery选择器语法允许在简单选择器的某些过滤器中使用圆括号，但并不允许使用圆括号来进行更常见的分组。例如，不能把选择器组或组合选择器放在圆括号中并且当成简单选择器:12(h1, h2, h3)+p //非法h1+p, h2+p, h3+p //正确的写法 总结语到此讲解了 jquery 的选择器.下一篇文章将讲解 选择器的选取方法.]]></content>
      <categories>
        <category>Technology</category>
        <category>HTML5</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>js</tag>
        <tag>JQuery</tag>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html5 新元素]]></title>
    <url>%2F2017%2F09%2F25%2FHtml5-%E6%96%B0%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[Html5 新元素自1999年以后HTML 4.01 已经改变了很多,今天，在HTML 4.01中的几个已经被废弃，这些元素在HTML5中已经被删除或重新定义。为了更好地处理今天的互联网应用，HTML5添加了很多新元素及功能，比如: 图形的绘制，多媒体内容，更好的页面结构，更好的形式 处理，和几个api拖放元素，定位，包括网页 应用程序缓存，存储，网络工作者，等。 canvas 新元素标签描述canvas标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API 新多媒体元素标签描述audio定义音频内容video定义视频（video 或者 movie）source定义多媒体资源 video 和 audioembed定义嵌入的内容，比如插件。track为诸如 video 和 audio 元素之类的媒介规定外部文本轨道。 新表单元素标签描述datalist定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。keygen规定用于表单的密钥对生成器字段。output定义不同类型的输出，比如脚本的输出。 新的语义和结构元素HTML5提供了新的元素来创建更好的页面结构： 标签描述article定义页面独立的内容区域。aside定义页面的侧边栏内容bdi允许您设置一段文本，使其脱离其父元素的文本方向设置command定义命令按钮，比如单选按钮、复选框或按钮detail用于描述文档或文档某个部分的细节。dialog 定义对话框，比如提示框summary标签包含 details 元素的标题figure规定独立的流内容（图像、图表、照片、代码等等）。figcaption定义 figure 元素的标题footer 定义 section 或 document 的页脚。header定义了文档的头部区域mark定义带有记号的文本。meter定义度量衡。仅用于已知最大和最小值的度量。nav定义运行中的进度（进程）。progress定义任何类型的任务的进度。ruby 定义 ruby 注释（中文注音或字符）rt 定义字符（中文注音或字符）的解释或发音rp在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。section定义文档中的节（section、区段）。time 定义日期或时间。wbr规定在文本中的何处适合添加换行符。 已移除的元素以下的 HTML 4.01 元素在HTML5中已经被删除: acronym applet basefont big center dir font frame frameset noframes strike tt]]></content>
      <categories>
        <category>Technology</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 获取当前网络连接类型]]></title>
    <url>%2F2017%2F09%2F22%2FAndroid-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[android 开发项目中,有时候需要风控为了尽量手机信息,需要传递当前的网络连接类型,就整理了一下 android 中怎样获取网络连接类型 用到的类 ConnectivityManager主要管理和网络连接相关的操作 相关的TelephonyManager则管理和手机、运营商等的相关信息；WifiManager则管理和wifi相关的信息。 NetworkInfo类包含了对wifi和mobile两种网络模式连接的详细描述,通过其getState()方法获取的State 添加权限想访问网络状态，首先得添加权限&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; 获取系统的网络服务首先要获取到系统的网络服务1ConnectivityManager connManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); 如果 connManager 为空,则是无网络. 获取网络类型获取当前网络类型，如果为空，返回无网络1NetworkInfo activeNetInfo = connManager.getActiveNetworkInfo(); 判断 wifi判断是不是连接的是不是wifi12345678NetworkInfo wifiInfo = connManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI); if (null != wifiInfo) &#123; NetworkInfo.State state = wifiInfo.getState(); if (null != state) if (state == NetworkInfo.State.CONNECTED || state == NetworkInfo.State.CONNECTING) &#123; return NETWORN_WIFI; &#125; &#125; 判断是不是 2g 3g 4g 等如果不是wifi，则判断当前连接的是运营商的哪种网络2g、3g、4g等1234567891011121314151617181920212223242526272829303132333435363738NetworkInfo networkInfo = connManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE); if (null != networkInfo) &#123; NetworkInfo.State state = networkInfo.getState(); String strSubTypeName = networkInfo.getSubtypeName(); if (null != state) if (state == NetworkInfo.State.CONNECTED || state == NetworkInfo.State.CONNECTING) &#123; switch (activeNetInfo.getSubtype()) &#123; //如果是2g类型 case TelephonyManager.NETWORK_TYPE_GPRS: // 联通2g case TelephonyManager.NETWORK_TYPE_CDMA: // 电信2g case TelephonyManager.NETWORK_TYPE_EDGE: // 移动2g case TelephonyManager.NETWORK_TYPE_1xRTT: case TelephonyManager.NETWORK_TYPE_IDEN: return NETWORN_2G; //如果是3g类型 case TelephonyManager.NETWORK_TYPE_EVDO_A: // 电信3g case TelephonyManager.NETWORK_TYPE_UMTS: case TelephonyManager.NETWORK_TYPE_EVDO_0: case TelephonyManager.NETWORK_TYPE_HSDPA: case TelephonyManager.NETWORK_TYPE_HSUPA: case TelephonyManager.NETWORK_TYPE_HSPA: case TelephonyManager.NETWORK_TYPE_EVDO_B: case TelephonyManager.NETWORK_TYPE_EHRPD: case TelephonyManager.NETWORK_TYPE_HSPAP: return NETWORN_3G; //如果是4g类型 case TelephonyManager.NETWORK_TYPE_LTE: return NETWORN_4G; default: //中国移动 联通 电信 三种3G制式 if (strSubTypeName.equalsIgnoreCase("TD-SCDMA") || strSubTypeName.equalsIgnoreCase("WCDMA") || strSubTypeName.equalsIgnoreCase("CDMA2000")) &#123; return NETWORN_3G; &#125; else &#123; return NETWORN_MOBILE; &#125; &#125; &#125; &#125; 由此就可以判断出 当前的网络连接类型了.完整代码下载路径 appinfoutils.java]]></content>
      <categories>
        <category>Technology</category>
        <category>Journal</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>wifi</tag>
        <tag>安卓</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂想]]></title>
    <url>%2F2017%2F09%2F20%2F%E6%9D%82%E6%83%B3%2F</url>
    <content type="text"><![CDATA[什么都不想写 ,好累!!困!!!!!!!!!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT 增加精品文章方法]]></title>
    <url>%2F2017%2F09%2F19%2FHexo-NexT-%E5%A2%9E%E5%8A%A0%E7%B2%BE%E5%93%81%E6%96%87%E7%AB%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[捣鼓了一下 置顶方法,又想折腾精品文章.和置顶方法类似. 精品 style首先增加精品的样式文件.在next 主题下面的 post.swig 找到如下代码.12345678910111213141516171819202122232425262728293031323334&#123;% if theme.post_wordcount.wordcount or theme.post_wordcount.min2read %&#125; &lt;div class="post-wordcount"&gt; &#123;% if theme.post_wordcount.wordcount %&#125; &#123;% if not theme.post_wordcount.separated_meta %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &#123;% endif %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-file-word-o"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_wordcount.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.wordcount') &#125;&#125;&amp;#58;&lt;/span&gt; &#123;% endif %&#125; &lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; &lt;/span&gt; &#123;% endif %&#125; &#123;% if theme.post_wordcount.wordcount and theme.post_wordcount.min2read %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &#123;% endif %&#125; &#123;% if theme.post_wordcount.min2read %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-clock-o"&gt;&lt;/i&gt; &lt;/span&gt; &#123;% if theme.post_wordcount.item_text %&#125; &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.min2read') &#125;&#125; &amp;asymp;&lt;/span&gt; &#123;% endif %&#125; &lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; &lt;/span&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% endif %&#125; 在后面添加以下代码 123456789101112131415&#123;% if post.top %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-thumb-tack zhidingtop"&gt;置顶&lt;/i&gt; &lt;/span&gt; &#123;% endif %&#125; &#123;% if post.top&amp;&amp;post.essential %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &#123;% endif %&#125; &#123;% if post.essential%&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-newspaper-o jingping"&gt;精品&lt;/i&gt; &lt;/span&gt; &#123;% endif %&#125; 增加 jingping css 样式12345.jingping&#123; background : #00a8c3; padding:2px 4px 2px 4px; color: #fff;&#125; 到此就完成了精品的设置.只要在文章的 md 文件中 加入如下代码1essential: true 就能看到设置的精品文章了 效果]]></content>
      <categories>
        <category>Technology</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>相册</tag>
        <tag>Photo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT 博客搭建相册(二)]]></title>
    <url>%2F2017%2F09%2F18%2FHexo-NexT-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%86%8C-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[上一篇文章 Hexo+NexT 博客搭建相册(一) 讲解了怎样用 github 来创建相册库.现在来讲解怎样在 hexo 中使用相册库. 准备工作按照 Hexo+NexT 博客搭建相册(一) 搭建好相册库. 增加相册style在 next 主题下面增加 photo.swig 页面.路径如下 next/layout 由于篇幅原因,大家可以在我的 github 上面下载 photo.swig 生成相册页面生成相册页面和生成分类和标签页面一样 hexo new page “photos” 修改 photos 下的 index.md文件由于字数限制,代码不贴出来了,大家可以在我的 github 上面下载index.md其中 &lt;a href=&quot;https://lovexinforever.github.io&quot; target=&quot;_blank&quot; class=&quot;open-ins&quot;&gt;图片正在加载中…&lt;/a&gt;中的 url 替换成你的博客网址.需要 三个 css 文件 和一个 js 文件.都在我的 github 上面 ,其中photoswipe.css和default-skin.css这 css 是查看图片插件的 css, 后面会说到,把这些 css 和 js 文件都在 photos 文件夹下面ins.cssphotoswipe.cssdefault-skinins.js需要修改 ins.js 的 120和121行的 url 为你 github 的图片的网址. 查看相册插件 photoswipe上面 index.md 中加入了两个 css 文件,这是我们用 photoswipe 查看相册用到的.具体可以参考网址 photoswipe这里我们已经把 css 文件加上了.之后我们要加上 js 文件 photoswipe.min.js 和photoswipe-ui-default.min.jsjs存放路径为 next/source/js/src 引用 js 文件在 _layout.swig 中插入在layout/_scripts/pages/post-details.swig 中插入12&lt;script src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/photoswipe.min.js?v=&#123;&#123; theme.version &#125;&#125;"&gt;&lt;/script&gt;&lt;script src="&#123;&#123; url_for(theme.js) &#125;&#125;/src/photoswipe-ui-default.min.js?v=&#123;&#123; theme.version &#125;&#125;"&gt;&lt;/script&gt; 放在 head 标签里面_layout.swig 路径为 next/layout 到这里已经差不多完成了相册查看,还差最后一步,在 index.html 中加入 标签. 在根目录加入标签在 _layout.swig 中 前插入1234567891011121314151617181920212223242526272829303132333435363738394041&#123;% if page.type === "photos" %&#125;&lt;!-- Root element of PhotoSwipe. Must have class pswp. --&gt;&lt;div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"&gt; &lt;div class="pswp__bg"&gt;&lt;/div&gt; &lt;div class="pswp__scroll-wrap"&gt; &lt;div class="pswp__container"&gt; &lt;div class="pswp__item"&gt;&lt;/div&gt; &lt;div class="pswp__item"&gt;&lt;/div&gt; &lt;div class="pswp__item"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="pswp__ui pswp__ui--hidden"&gt; &lt;div class="pswp__top-bar"&gt; &lt;div class="pswp__counter"&gt;&lt;/div&gt; &lt;button class="pswp__button pswp__button--close" title="Close (Esc)"&gt;&lt;/button&gt; &lt;button class="pswp__button pswp__button--share" title="Share"&gt;&lt;/button&gt; &lt;button class="pswp__button pswp__button--fs" title="Toggle fullscreen"&gt;&lt;/button&gt; &lt;button class="pswp__button pswp__button--zoom" title="Zoom in/out"&gt;&lt;/button&gt; &lt;!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR --&gt; &lt;!-- element will get class pswp__preloader--active when preloader is running --&gt; &lt;div class="pswp__preloader"&gt; &lt;div class="pswp__preloader__icn"&gt; &lt;div class="pswp__preloader__cut"&gt; &lt;div class="pswp__preloader__donut"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"&gt; &lt;div class="pswp__share-tooltip"&gt;&lt;/div&gt; &lt;/div&gt; &lt;button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"&gt; &lt;/button&gt; &lt;button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"&gt; &lt;/button&gt; &lt;div class="pswp__caption"&gt; &lt;div class="pswp__caption__center"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; 至此相册查看插件 photoswipe 已经配置完毕. 整个流程使用 在 blog_back_up 里面加入图片,图片路径在 photos 里面 图片命名方式 yyyy-MM-dd_des.jpg/jpeg/gif/png. 执行 python3 tool.py 切换到博客 resource 目录下 在 photos 里面生成了 data.json 文件 提交到github 上面. 输入网址查看照片. 效果展示]]></content>
      <categories>
        <category>Technology</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>相册</tag>
        <tag>Photo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT 博客搭建相册(一)]]></title>
    <url>%2F2017%2F09%2F18%2FHexo-NexT-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9B%B8%E5%86%8C-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[用Hexo + NexT 搭建了博客之后,就想搭建一个相册.ps:真是瞎折腾!.自己上网查了些资料,摸索摸索,终于搭建好了.这里写个教程,由于东西比较多,教程分为两部分. 实现想法在 github 上面创建一个相册库,当有更新时,提交到 github 上面,同时在博客 resource 下面生成一个 data.json来生成所有相册文件的 json 文件,博客读取 data.json 来展示相册 创建相册库在 github 上面创建一个仓库,命名为 blog_back_up (仓库名字随便). 用 git clone 把仓库 clone 到本地来. cd blog_back_up 创建 photos 和 min_photos 两个目录,把要上传的相册图片 放到 photos 文件夹下面. 相册图片命名方式 : yyyy-MM-dd_des.jpg/png/jpef/gif. eg: 2017-9-18_蝴蝶. jpg 处理图片图片的处理 我用 python 脚本来处理,这样每次只要执行脚本就可以了. 裁剪图片 12345678910111213141516171819202122def cut_photo(): """裁剪算法 ---------- 调用Graphics类中的裁剪算法，将src_dir目录下的文件进行裁剪（裁剪成正方形） """ src_dir = "photos/" if directory_exists(src_dir): if not directory_exists(src_dir): make_directory(src_dir) # business logic file_list = list_img_file(src_dir) # print file_list if file_list: print_help() for infile in file_list: img = Image.open(src_dir+infile) Graphics(infile=src_dir+infile, outfile=src_dir + infile).cut_by_ratio() else: pass else: print("source directory not exist!") 压缩图片 1234567891011121314151617181920def compress_photo(): '''调用压缩图片的函数 ''' src_dir, des_dir = "photos/", "min_photos/" if directory_exists(src_dir): if not directory_exists(src_dir): make_directory(src_dir) # business logic file_list_src = list_img_file(src_dir) if directory_exists(des_dir): if not directory_exists(des_dir): make_directory(des_dir) file_list_des = list_img_file(des_dir) # print file_list '''如果已经压缩了，就不再压缩''' for i in range(len(file_list_des)): if file_list_des[i] in file_list_src: file_list_src.remove(file_list_des[i]) compress('4', des_dir, src_dir, file_list_src) 根据图片信息生成 json 1234567891011121314151617181920212223242526272829303132333435363738394041def handle_photo(): '''根据图片的文件名处理成需要的json格式的数据 ----------- 最后将data.json文件存到博客的source/photos文件夹下 ''' src_dir, des_dir = "photos/", "min_photos/" file_list = list_img_file(src_dir) list_info = [] for i in range(len(file_list)): filename = file_list[i] date_str, info = filename.split("_") info, _ = info.split(".") date = datetime.strptime(date_str, "%Y-%m-%d") year_month = date_str[0:7] if i == 0: # 处理第一个文件 new_dict = &#123;"date": year_month, "arr":&#123;'year': date.year, 'month': date.month, 'link': [filename], 'text': [info], 'type': ['image'] &#125; &#125; list_info.append(new_dict) elif year_month != list_info[-1]['date']: # 不是最后的一个日期，就新建一个dict new_dict = &#123;"date": year_month, "arr":&#123;'year': date.year, 'month': date.month, 'link': [filename], 'text': [info], 'type': ['image'] &#125; &#125; list_info.append(new_dict) else: # 同一个日期 list_info[-1]['arr']['link'].append(filename) list_info[-1]['arr']['text'].append(info) list_info[-1]['arr']['type'].append('image') list_info.reverse() # 翻转 final_dict = &#123;"list": list_info&#125; with open("../../blog/blog_src/source/photos/data.json","w") as fp: json.dump(final_dict, fp) 其中 ../../blog/blog_src/source/photos/data.json 是我博客地址,这里换成你的博客地址.完成的 python 下载地址 tool.py 使用python3 tool.py因为我用的是 python3 这里可以根据你的 python 版本来使用 QA:如果出现 from PIL import Image 这里报错.说明没有 PIL 这个库.执行 python3 -m pip install Pillow 结束语目前为止,相册库已经处理完毕,接下来会更新 hexo 怎么使用相册库.Hexo+NexT 博客搭建相册(二)]]></content>
      <categories>
        <category>Technology</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>相册</tag>
        <tag>Photo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现单行、多行文本溢出显示省略号（…）]]></title>
    <url>%2F2017%2F09%2F14%2FCSS%E5%AE%9E%E7%8E%B0%E5%8D%95%E8%A1%8C%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7(...)%2F</url>
    <content type="text"><![CDATA[如果实现单行文本的溢出显示省略号同学们应该都知道用text-overflow:ellipsis属性来，当然还需要加宽度width属来兼容部分浏览。 单行显示实现方法12345.singer &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; &#125; 效果如图 但是这个属性只支持单行文本的溢出显示省略号，如果我们要实现多行文本溢出显示省略号呢。 多行显示实现方法12345678.multiline &#123; margin-top: 20px; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; width: 300px; &#125; 效果如图 代码下载]]></content>
      <categories>
        <category>Technology</category>
        <category>HTML5</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
        <tag>CSS</tag>
        <tag>HTML5</tag>
        <tag>单行显示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 正则判断是否是手机号]]></title>
    <url>%2F2017%2F09%2F14%2Fjs-%E6%AD%A3%E5%88%99%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E6%89%8B%E6%9C%BA%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[做项目时,遇到手机号注册,需要判断用户输入是否为手机号,就写了段正则判断. js 如下12345678function checkMobile(str) &#123; var re = /^1\d&#123;10&#125;$/ if (re.test(str)) &#123; return true; &#125; else &#123; return false; &#125;&#125;]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>正则</tag>
        <tag>判断手机号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加文章置顶功能]]></title>
    <url>%2F2017%2F09%2F13%2FHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A1%B6%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[原来用的WordPress，直接很方便地管理置顶文章，Hexo只提供了按发布日期的排序，只好网上找了些资料修改。 原理：在Hexo生成首页HTML时，将top值高的文章排在前面，达到置顶功能。修改Hexo文件夹下的node_modules/hexo-generator-index/lib/generator.js，在生成文章之前进行文章top值排序。 需添加的代码：12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;); 修改完成后，只需要在front-matter中设置需要置顶文章的top值，将会根据top值大小来选择置顶顺序top值越大越靠前。需要注意的是，这个文件不是主题的一部分，也不是Git管理的，备份的时候比较容易忽略。 以下是最终的generator.js内容12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;;]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>置顶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的版本控制与持续集成]]></title>
    <url>%2F2017%2F09%2F13%2FHexo%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[人生并不像火车要通过每个站似的经过每一个生活阶段。人生总是直向前行走，从不留下什么。—— 刘易斯想必很多人会把Hexo生成出来的静态网站放到GitHub Pages来进行托管。一般发布Hexo博客的流程是，首先在本地搭建Hexo的环境，编写新文章，然后利用hexo deploy来发布到Git。那么对于本地的Hexo的原始文件怎么管理呢？如果换电脑了怎么办？如果没有对原始文件进行备份，突然有一天你的本地环境挂了导致源文件丢失，那不就呵呵了。也许你会想到用Dropbox或者其他方案来对源文件进行备份，但是每次更新完博客，需要备份好源文件，然后执行hexo deploy进行发布，是不是很麻烦？换了电脑之后又要重新搭建本地环境，是不是很蛋疼？那么接下来我们就来说说如何优雅愉快地对我们的Hexo进行版本管理和发布。既然我们已经用了GitHub来托管我们生成出来的静态网站，那么为什么不也把Hexo博客的源文件也host在GitHub上呢。那么问题来了，如果我们把Hexo博客的源文件托管在GitHub上，我们的发布流程就会变为： 执行git push把更新的源文件push到托管源文件的GitHub Repo (我们称之为Source Repo) 执行hexo deploy来更新托管静态网站的GitHub Pages (我们称之为Content Repo) 这样看来，每次更新博客要经历两个步骤，并不是那么straightforward。那么有没有办法做到既能使用GitHub进行版本控制，又能做到一键发布呢？答案是肯定的。这里用到了持续集成也就是我们一直所说的CI来完成一键发布：当有新的change push到Source Repo时，自动执行CI脚本，生成最新的静态网站发布到Content Repo，一气呵成。那么我使用什么CI工具来做呢？我们可以使用像Travis CI这样的Hosted CI Service，也可以使用Jenkins或者TeamCity来搭建CI server。如果自己来搭建CI Server，费时费力，又要花钱来买Server来host CI service，肯定不是一个很好的选择。那么我们选哪个Hosted CI Service呢？其实今年在公司的一个项目中我们就选择了AppVeyor。当初在做investigation的时候，第一个想到的就是用Travis CI，访问AppVeyor官网，映入眼帘的大标题就是#1 Continuous Delivery service for Windows。刚开始的时候内心一阵嘲笑，Top 10的CI Service就你支持Windows，你不是第一那谁是第一？结果在之后的项目使用中，发现AppVeyor比Travis CI好用太多。这里就不具体展开了，继续进入正题。使用AppVeyor来建立CI非常方便，主要是以下步骤： 注册并登陆 AppVeyor访问AppVeyor登陆页面，使用你的GitHub账号登陆即可。 添加 Project在AppVeyor Projects页面，添加相应的GitHub Source Repo。 添加appveyor.yml到Source Repo接下来，你需要把appveyor.yml添加到Source Repo的根目录下。具体的appveyor.yml如下.也可以参考我的博客AppVeyor.yml 你唯一需要做的就是替换[Your GitHub Access Token]，关于生成Access Token，可以参考这篇文章。在GitHub生成好Access Token之后，你需要到AppVeyor加密页面把Access Token加密之后再替换[Your GitHub Access Token] 设置Appveyor添加好appveyor.yml之后，再到Appveyor portal设置以下四个变量。STATIC_SITE_REPO就是Content Repo的地址，TARGET_BRANCH就是你Content Repo的branch，一般默认就是master，GIT_USER_EMAIL和GIT_USER_NAME就是你GitHub账号的信息。 好了，一切大功告成！试一下git push你的change到Source Repo，几分钟内，你的博客就自动更新了！背后的过程如下: Git push to Source Repo AppVeyor CI Update GitHub Pages Content Repo Generate your Hexo blog site 谢谢!]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>持续集成</tag>
        <tag>版本管理</tag>
        <tag>CI</tag>
        <tag>AppVeyor</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 下配置多个 ssh]]></title>
    <url>%2F2017%2F09%2F12%2FMac-%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA-ssh%2F</url>
    <content type="text"><![CDATA[人的一切痛苦，本质上都是对自己无能的愤怒总有刁民想害朕 我们每个人都有多个仓库来提交代码,工作中的和个人的.本篇文章就教你怎样管理多个 ssh 来提交代码.查看 .ssh 文件夹下面的文件一种是直接进入 .ssh 文件目录 cd ~/.ssh 或者 直接查看 .ssh 文件夹 ls ~/.ssh 生成一个SSH-Key ssh-keygen -t rsa -C “tim_ding@qq.com“ 如果 .ssh 文件下已经有文件了 ,最好重新命名密码建议填空 成功生成 SSH-KEY 配置 SSH-KEY在~/.ssh/目录下会生成id-rsa_hostname和id-rsa_hostname.pub私钥和公钥。 我们将id-rsa_hostname.pub中的内容粘帖到服务器的SSH-key的配置中。 cat ~/.ssh/github_blog_rsa.pub 在GitHub的设置中粘贴公钥 至此, ssh 就配置完成了. 验证配置是否成功 ssh -T git@github.com 笔者出现了如下错误那是因为目录下有多个 ssh, 需要配置 config 打开 config 文件 vim ~/.ssh/config 添加如下 Host github.com HostName github.com User timding IdentityFile ~/.ssh/github_blog_rsa 然后保存.再执行 ssh -T git@github.com 就成功了.]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Toast 类分装]]></title>
    <url>%2F2016%2F06%2F01%2FAndroid-Toast-%E7%B1%BB%E5%88%86%E8%A3%85%2F</url>
    <content type="text"><![CDATA[每天积累一点总有刁民想害朕 Android Toast的用法由于最近开发需要用到大量Toast.所以做了个分装 ToastUtils.java /** * toast弹出窗类，项目的toast弹出框必须从这里开始 * 不允许自行实例化 * @author TD * */ @SuppressLint("ShowToast") public final class ToastUtils { static Toast mToast = null; private ToastUtils(){} /** * 长时间气泡弹出 * @param message */ public static void toastLong(String message){ if(!TextUtils.isEmpty(message)){ getToast(); mToast.setText(message); mToast.setDuration(Toast.LENGTH_LONG); mToast.show(); } } /** * 长时间气泡弹出 * @param resId */ public static void toastLong(int resId){ getToast(); mToast.setText(resId); mToast.setDuration(Toast.LENGTH_LONG); mToast.show(); } /** * 改变位置，长时间显示气泡 * @param message * @param gravity * @param xOffset * @param yOffset */ public static void toastLong(String message,int gravity,int xOffset,int yOffset){ getToast(); mToast.setText(message); mToast.setDuration(Toast.LENGTH_LONG); mToast.setGravity(gravity, xOffset, yOffset); mToast.show(); } /** * 自定义view长时间显示气泡 * @param message * @param view */ public static void toastLong(View view){ getToast(); mToast.setView(view); mToast.setDuration(Toast.LENGTH_LONG); mToast.show(); } /** * 改变位置，自定义View长时间显示气泡 * @param message * @param view * @param gravity * @param xOffset * @param yOffset */ public static void toastLong(View view,int gravity,int xOffset,int yOffset){ getToast(); mToast.setView(view); mToast.setDuration(Toast.LENGTH_LONG); mToast.setGravity(gravity, xOffset, yOffset); mToast.show(); } /** * 短时间弹出气泡 * @param message */ public static void toastShort(String message){ if(!TextUtils.isEmpty(message)){ getToast(); mToast.setText(message); mToast.setDuration(Toast.LENGTH_SHORT); mToast.show(); } } /** * 短时间弹出气泡 * @param resId */ public static void toastShort(int resId){ getToast(); mToast.setText(resId); mToast.setDuration(Toast.LENGTH_SHORT); mToast.show(); } /** * 改变位置，短时间显示气泡 * @param message * @param gravity * @param xOffset * @param yOffset */ public static void toastShort(String message,int gravity,int xOffset,int yOffset){ getToast(); mToast.setText(message); mToast.setDuration(Toast.LENGTH_SHORT); mToast.setGravity(gravity, xOffset, yOffset); mToast.show(); } /** * 自定义view短时间显示气泡 * @param message * @param view */ public static void toastShort(View view){ getToast(); mToast.setView(view); mToast.setDuration(Toast.LENGTH_SHORT); mToast.show(); } /** * 改变位置，自定义View短时间显示气泡 * @param message * @param view * @param gravity * @param xOffset * @param yOffset */ public static void toastShort(View view,int gravity,int xOffset,int yOffset){ getToast(); mToast.setView(view); mToast.setDuration(Toast.LENGTH_SHORT); mToast.setGravity(gravity, xOffset, yOffset); mToast.show(); } /** * 获得一个气泡的实例 * @return */ public static Toast getToast(){ if(null != mToast){ mToast.cancel(); } mToast = null; mToast = Toast.makeText(IApplication.mContactsApp, "", Toast.LENGTH_SHORT); return mToast; } }]]></content>
      <categories>
        <category>Technology</category>
        <category>Journal</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六一儿童节]]></title>
    <url>%2F2016%2F06%2F01%2F%E5%85%AD%E4%B8%80%E5%84%BF%E7%AB%A5%E8%8A%82%2F</url>
    <content type="text"><![CDATA[世上无难事,只怕有心人总有刁民想害朕 六一儿童节新规定公司规定必须穿西装,皮鞋,衬衫.我去,感觉跟卖房子的一样!!! 但还是乖乖的穿上了.]]></content>
      <categories>
        <category>Journal</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搬家]]></title>
    <url>%2F2016%2F05%2F30%2F%E6%90%AC%E5%AE%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[github 上传代码 菜鸟超详细教程]]></title>
    <url>%2F2015%2F12%2F29%2Fgithub-%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81-%E8%8F%9C%E9%B8%9F%E8%B6%85%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[由于最近需要把代码上传到github上,之前只是用来fork别人的代码.所以写了这篇文章.运行环境windows. 当然需要有github账号,没有的话,请移步Github 新建仓库图中红色部分都可以新建 填写名称，简介（可选），勾选Initialize this repository with a README选项，这是自动创建REAMDE.md文件，省的你再创建. 用git shell 连接 github ssh.不会的话请移步设置ssh keys clone刚才新建的repository 到本地，输入命令：git clone https://github.com/lovexinforever/blog.git这时会在目录下生成： 将想上传的代码目录拷贝到此文件夹下： 切换到Git shell 命令行下，输入命令： git init git commit -m &#39;blog&#39; git remote add origin https://github.com/lovexinforever/blog.git git push origin master如果执行git remote add origin https://github.com/lovexinforever/blog.git，出现错误： fatal: remote origin already exists则执行以下语句： git remote rm origin再往后执行git remote add origin https://github.com/lovexinforever/blog.git 即可。 在执行git push origin master时，报错： error:failed to push som refs to.......则执行以下语句： git pull origin master先把远程服务器github上面的文件拉先来，再push 上去。 至此,就把本地代码提交到远程github上了. 谢谢 欢迎转载!!]]></content>
      <categories>
        <category>Technology</category>
        <category>Journal</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于用 hexo d 失败的解决方法]]></title>
    <url>%2F2015%2F12%2F25%2F%E5%85%B3%E4%BA%8E%E7%94%A8-hexo-d-%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[搭建 hexo，在执行 hexo deploy 后,出现 error deployer not found:github 的错误 这是hexo 更新到3.0 会出现的错误 解决方法 在_config.yml 中配置如下 其中红色部分是你的github名.]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 创建文章 demo]]></title>
    <url>%2F2015%2F12%2F23%2Fhexo-%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0-demo%2F</url>
    <content type="text"><![CDATA[千里之行,始于足下总有刁民想害朕 关于hexo 发布文章的一些标签的用法这部分Docs分了8块内容，分别从写作、前置声明、标签插件、资源目录、数据文件、服务器、生成器、部署。也许翻译得不得当，但是我尽量把主要内容呈现出来并加上自己的理解。 写作 写作之前当然得先创建一个.md文件，使用命令hexo new [layout] &lt;title&gt;，其中layout默认为post，前面提过。 （1）Layout布局 Hexo提供了3种默认的布局，post、page和draft，路径分别为：source/_posts、source、source/_draft。如果你将在文章前置申明中，将layout设置为false，那么这篇文章将不会有任何的布局。 （2）Filename文件名 Hexo会默认将文章的标题当做文件名，但是你可以编辑_config.yml配置文件中的new_post_name来改变默认的文件名。 例如：使用hexo new hello命令创建一篇为hello文章，Hexo会默认在_posts目录下给你创建一个名为hello.md的文件。假如你将new_post_name改为了:year-:month-:day-:title.md，那么hexo就自动帮你创建名为2015-12-23-hello.md（当前日期为2015年12月23） :title 文章标题 :year 创建年份 :month 月份，如4月为04 :day 日期 i_month 月份，单数字，比如4月就是4 i_day 同上 （3）Drafts草稿 Hexo提供草稿功能，在_drafts目录下的文章不会发表到网站上，你可以通过命令hexo publish [layout] &lt;title&gt;发布你的草稿，改命令会将文章移到_posts目录下。但是也可以设置_config.yml配置文件的render_drafts字段，使草稿默认发布到站点中。 （4）Scaffolds模版 当你使用new命令创建一篇文章的时候，Hexo会根据scaffolds目录中的模版帮你生成文章。假如执行hexo new photo &quot;My Gallery&quot;，Hexo会尝试在scaffolds目录中去寻找photo.md的模版文件，然后基于它创建标题为My Gallery的文章。 它的用处就是能够在模版中写入你某一类文章都要添加的共同内容，这样你基于模版创建文章的时候，就不用再重复写入那部分内容。 前置声明 顾名思义，就是写在文章前面的一块内容，为了对文章进行某些设置。它有两种书写方式： YAML方式，以三短线结束YAML123title: Hello Worlddate: 2015/12/23 20:46:25--- JSON方式，以三分号结束JSON123"title": "Hello World","date": "2013/7/13 20:46:25";;; 下面看看有哪些参数可以设定： layout 布局，一般不用写，默认就行 title 标题，这个必须要有 date 时间 updated 修改时间 comments 是否开启评论，默认为true tags 文章标签 categories 文章分类 permalink 文章永久链接，一般不用写，默认就行在写标签和分类的时候，可能会有多个的情况，多个标签可以无序排列的方式书写，而分类可能会有多级分类的情况。如何书写举例如下： YAML1234567categories: - Sports- Baseballtags:- Injury- Fight- Shocking 标签插件 这里说的标签插件不同于文章中的标签，它可以帮助你在文章中快速嵌入一些特殊的内容。 （1）Block Quote-块引用 插入带有作者信息的应用，体现在Html上就是在blockquote标签下加入了footer标签。但是会给文章带来不一样的显示效果，书写格式非常简单。 看下面的例子就大概知道怎么书写了，第一种最简单的方式就等于markdown里的&gt;语句。显示效果为（主题为light-ch）：（2）Code Block代码块 在文章中插入代码块可以使用下面方式书写同样举个例子，用法一目了然。显示效果如下：（3）Pull Quote 这个插件可以帮助您在文章中插入重要引述。（4）jsFiddle 在文章中嵌入jsFiddle片段。 （5）Gist 嵌入Gist片段（6）iFrame 插入网页框架（7）Image 插入图片，可以自定义大小（8）Link 插入带有target=”_blank”属性值的链接。（9）Include Code 从资源目录中插入代码片段。（10）Youtube 在文章中插入Youtube视频。天朝的孩子就不用试了（11）Vimeo 在文章中插入Vimeo视频。（12）Include Posts 包含其他文章的链接。（13）Include Assets 包含文章资源。(具体怎么使用，还不太明白，后续再补充)（14）Raw 一些内容不想被主题渲染，可以使用该插件呈现原始状态。]]></content>
      <categories>
        <category>Technology</category>
        <category>Journal</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
